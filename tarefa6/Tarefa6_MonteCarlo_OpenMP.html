<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tarefa 6 - Estimativa de œÄ com Monte Carlo e OpenMP</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
        }
        h1, h2 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h1 {
            text-align: center;
            margin-bottom: 30px;
        }
        .code-block {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-left: 4px solid #3498db;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
        }
        .problem {
            background-color: #fee;
            border-left: 4px solid #e74c3c;
            padding: 15px;
            margin: 15px 0;
        }
        .solution {
            background-color: #eafaf1;
            border-left: 4px solid #27ae60;
            padding: 15px;
            margin: 15px 0;
        }
        .warning {
            background-color: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #3498db;
            color: white;
        }
        tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        .math {
            background-color: #e8f4f8;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-style: italic;
            text-align: center;
        }
        .clause-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .clause-card {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            background: #f9f9f9;
        }
        .clause-card h4 {
            color: #2980b9;
            margin-top: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Tarefa 6 - Estimativa Estoc√°stica de œÄ com OpenMP</h1>
        
        <h2>M√©todo de Monte Carlo</h2>
        <p>O m√©todo de Monte Carlo estima œÄ atrav√©s de simula√ß√£o estat√≠stica:</p>
        
        <div class="math">
            <strong>Conceito:</strong> Gerar pontos aleat√≥rios em um quadrado [-1,1]¬≤ e contar quantos caem dentro do c√≠rculo de raio 1<br>
            <strong>F√≥rmula:</strong> œÄ ‚âà 4 √ó (pontos_dentro_c√≠rculo / total_pontos)
        </div>
        
        <h2>Implementa√ß√µes Desenvolvidas</h2>
        
        <h3>1. Vers√£o Sequencial (Refer√™ncia)</h3>
        <div class="solution">
            <strong>VERS√ÉO BASE:</strong> Implementa√ß√£o sequencial para compara√ß√£o de performance
        </div>
        
        <div class="code-block">
    double estimar_pi_sequencial(long num_pontos) {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;long pontos_dentro = 0;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;for (long i = 0; i < num_pontos; i++) {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double x = random(-1, 1);<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double y = random(-1, 1);<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (x*x + y*y <= 1.0) {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pontos_dentro++;<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
    &nbsp;&nbsp;&nbsp;&nbsp;}<br>
    &nbsp;&nbsp;&nbsp;&nbsp;return 4.0 * pontos_dentro / num_pontos;<br>
    }
        </div>
        
        <h3>2. Vers√£o com Condi√ß√£o de Corrida usando #pragma omp parallel for</h3>
        <div class="problem">
            <strong>PROBLEMA CR√çTICO:</strong> M√∫ltiplas threads modificam a mesma vari√°vel simultaneamente sem sincroniza√ß√£o!
        </div>
        
        <div class="code-block">
    long pontos_dentro = 0; // Vari√°vel compartilhada sem prote√ß√£o!<br>
    <br>
    #pragma omp parallel for<br>
    for (long i = 0; i < num_pontos; i++) {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;// ... c√°lculos ...<br>
    &nbsp;&nbsp;&nbsp;&nbsp;if (x*x + y*y <= 1.0) {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pontos_dentro++; // CONDI√á√ÉO DE CORRIDA!<br>
    &nbsp;&nbsp;&nbsp;&nbsp;}<br>
    }
        </div>
        
        <div class="problem">
            <strong>üîç Por que `pontos_dentro++` √© perigoso em paralelo?</strong><br><br>
            
            A opera√ß√£o <code>pontos_dentro++</code> parece ser uma √∫nica instru√ß√£o at√¥mica, mas o processador na verdade executa <strong>3 opera√ß√µes separadas</strong>:
            
    <div style="background-color: #fff3e0; padding: 15px; margin: 10px 0; border-radius: 5px; border-left: 4px solid #ff9800;">
        <strong>1. LOAD (Carregar):</strong> Buscar o valor atual de <code>pontos_dentro</code> da mem√≥ria para o registrador<br>
        <strong>2. INCREMENT (Incrementar):</strong> Somar 1 ao valor no registrador<br>
        <strong>3. STORE (Armazenar):</strong> Escrever o novo valor do registrador de volta para a mem√≥ria
    </div>
    
    <strong>‚ö° Race Condition em A√ß√£o: O Cen√°rio do Desastre</strong><br>
    <em>Imagine que <code>pontos_dentro = 15.000</code> e duas threads (A e B) encontram pontos dentro do c√≠rculo simultaneamente:</em>

    <div style="background-color: #f5f5f5; padding: 12px; border-radius: 4px; margin: 10px 0; font-family: monospace;">
        <strong>Timeline da Execu√ß√£o Paralela:</strong><br>
        <span style="color: #1976d2;">Thread A:</span> LOAD pontos_dentro ‚Üí registrador_A = 15.000<br>
        <span style="color: #d32f2f;">Thread B:</span> LOAD pontos_dentro ‚Üí registrador_B = 15.000 <strong style="background-color: #ffeb3b;">‚Üê MESMA LEITURA!</strong><br>
        <span style="color: #1976d2;">Thread A:</span> INCREMENT registrador_A ‚Üí registrador_A = 15.001<br>
        <span style="color: #d32f2f;">Thread B:</span> INCREMENT registrador_B ‚Üí registrador_B = 15.001<br>
        <span style="color: #1976d2;">Thread A:</span> STORE registrador_A ‚Üí pontos_dentro = 15.001<br>
        <span style="color: #d32f2f;">Thread B:</span> STORE registrador_B ‚Üí pontos_dentro = 15.001 <strong style="background-color: #ffcdd2;">‚Üê SOBRESCREVE!</strong>
    </div>

    <div style="background-color: #ffebee; padding: 12px; border-radius: 4px; margin-top: 10px;">
        <strong style="color: #d32f2f;">‚ùå PROBLEMA FUNDAMENTAL:</strong> <em>Lost Update</em> - Ambas threads leram o mesmo valor inicial<br>
        <strong style="color: #d32f2f;">üìä RESULTADO INCORRETO:</strong> pontos_dentro = 15.001 (deveria ser 15.002)<br>
        <strong style="color: #d32f2f;">üí• IMPACTO CR√çTICO:</strong> Uma contagem perdida = Estimativa de œÄ incorreta<br>
        <strong style="color: #d32f2f;">üîÑ FREQU√äNCIA:</strong> Acontece milhares de vezes em execu√ß√µes paralelas!
    </div>

    <div style="background-color: #e8f5e8; padding: 12px; border-radius: 4px; margin-top: 10px;">
        <strong style="color: #2e7d32;">‚úÖ ANALOGIA PR√ÅTICA:</strong> <br>
        √â como duas pessoas tentando atualizar o mesmo documento ao mesmo tempo - uma das altera√ß√µes sempre se perde porque ambas trabalharam com a vers√£o antiga!
    </div>

    <div style="background-color: #e3f2fd; padding: 12px; border-radius: 4px; margin-top: 10px;">
        <strong style="color: #1565c0;">üéØ POR QUE ISSO IMPORTA NO MONTE CARLO:</strong><br>
        ‚Ä¢ Cada ponto perdido = erro na estimativa de œÄ<br>
        ‚Ä¢ Com milh√µes de pontos, centenas de milhares podem ser perdidos<br>
        ‚Ä¢ Resultado: œÄ calculado ser√° sempre menor que o valor real<br>
    </div>
        </div>
        
        <p><strong>Resultados Inconsistentes Observados:</strong></p>
        <table>
            <tr><th>Execu√ß√£o</th><th>œÄ Estimado</th><th>Erro</th><th>Tempo (s)</th><th>Explica√ß√£o</th></tr>
            <tr><td>1</td><td>0.913476</td><td>70.923%</td><td>2.8614</td><td rowspan="3">Com 250M pontos: perdeu ~70% dos incrementos</td></tr>
            <tr><td>2</td><td>0.865560</td><td>72.448%</td><td>2.7982</td></tr>
            <tr><td>3</td><td>0.911949</td><td>70.972%</td><td>2.8158</td></tr>
        </table>
        
        <h3>3. Corre√ß√£o com #pragma omp critical</h3>
        <div class="solution">
            <strong>CORRE√á√ÉO FUNCIONAL:</strong> Apenas uma thread por vez pode incrementar a vari√°vel
        </div>
        
        <div class="code-block">
    #pragma omp parallel for<br>
    for (long i = 0; i < num_pontos; i++) {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;// ... c√°lculos ...<br>
    &nbsp;&nbsp;&nbsp;&nbsp;if (x*x + y*y <= 1.0) {<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#pragma omp critical<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pontos_dentro++; // Protegido contra race condition<br>
    &nbsp;&nbsp;&nbsp;&nbsp;}<br>
    }
        </div>
        
        <div class="warning">
            <strong>‚ö†Ô∏è POR QUE ESTA ABORDAGEM N√ÉO √â √ìTIMA:</strong><br><br>
            
            <strong>üö¶ O Gargalo em A√ß√£o:</strong><br>
            ‚Ä¢ <strong>Threads esperando:</strong> Quando uma thread est√° no critical, todas as outras ficam bloqueadas<br>
            ‚Ä¢ <strong>Serializa√ß√£o for√ßada:</strong> 4 threads executando como se fosse 1 thread<br>
            ‚Ä¢ <strong>Overhead de sincroniza√ß√£o:</strong> Cada critical section tem custo computacional<br><br>
            
            <strong>üìä An√°lise de Performance (250M pontos, ~196M hits):</strong><br>
            ‚Ä¢ <strong>Tempo total:</strong> 21.28s (vs 3.62s sequencial)<br>
            ‚Ä¢ <strong>Speedup:</strong> 0.17x (na verdade ficou <strong>6x mais lento!</strong>)<br>
            ‚Ä¢ <strong>Critical sections executadas:</strong> ~196.000.000 (uma para cada ponto dentro do c√≠rculo)<br>
            ‚Ä¢ <strong>Tempo perdido:</strong> Threads ficam 80% do tempo esperando na fila do critical
        </div>
        
        <h3>4. Reestrutura√ß√£o com #pragma omp parallel seguido de #pragma omp for</h3>
        <div class="solution">
            <strong>SOLU√á√ÉO INTELIGENTE:</strong> Separar a regi√£o paralela do loop e usar acumula√ß√£o local
        </div>
        
        <div class="solution">
            <strong>üöÄ Por que esta abordagem √© √≥tima?</strong><br><br>
            
            <strong>‚ö° Compara√ß√£o de Sincroniza√ß√µes:</strong>
            <table style="margin: 10px 0; font-size: 14px;">
                <tr><th>Abordagem</th><th>Sincroniza√ß√µes</th><th>Exemplo (250M pontos, ~196M hits)</th></tr>
                <tr style="background-color: #ffebee;">
                    <td><code>#pragma omp critical</code><br>dentro do loop</td>
                    <td>A cada incremento</td>
                    <td><strong>~196.000.000 sincroniza√ß√µes!</strong><br>Cada hit = 1 critical section</td>
                </tr>
                <tr style="background-color: #e8f5e8;">
                    <td><code>#pragma omp parallel</code><br>+ acumula√ß√£o local</td>
                    <td>Uma por thread</td>
                    <td><strong>4 sincroniza√ß√µes</strong><br>Uma por thread no final</td>
                </tr>
            </table>
            
            <strong>üîß Funcionamento Passo a Passo:</strong>
            <ol>
                <li><strong>Cria√ß√£o das Threads:</strong> <code>#pragma omp parallel</code> cria 4 threads</li>
                <li><strong>Vari√°veis Locais:</strong> Cada thread tem sua pr√≥pria <code>pontos_locais = 0</code></li>
                <li><strong>Divis√£o do Trabalho:</strong> <code>#pragma omp for</code> divide 250M itera√ß√µes entre 4 threads</li>
                <li><strong>Acumula√ß√£o Local:</strong> Cada thread incrementa apenas sua vari√°vel local</li>
                <li><strong>Sincroniza√ß√£o Final:</strong> Apenas no final, cada thread adiciona sua soma ao total</li>
            </ol>
            
            <strong>üèÜ Resultados da Performance:</strong>
            <ul>
                <li><strong>Tempo:</strong> 1.28s vs 21.28s do critical (16.7x mais r√°pido!)</li>
                <li><strong>Speedup:</strong> 2.8x comparado ao sequencial (com 4 threads)</li>
                <li><strong>Precis√£o:</strong> Mant√©m a corre√ß√£o completa dos resultados</li>
                <li><strong>Escalabilidade:</strong> Performance melhora com mais threads dispon√≠veis</li>
            </ul>
        </div>
        
        <h2>Performance Comparada</h2>
        <table>
            <tr>    
                <th>Vers√£o</th>
                <th>Tempo (s)</th>
                <th>œÄ Estimado</th>
                <th>Erro (%)</th>
                <th>Speedup</th>
                <th>Observa√ß√µes</th>
            </tr>
            <tr>
                <td>Sequencial</td>
                <td>3.6101</td>
                <td>3.141578</td>
                <td>0.000%</td>
                <td>1.0x</td>
                <td>Refer√™ncia (250M pontos)</td>
            </tr>
            <tr style="background-color: #ffe6e6;">
                <td>Race Condition</td>
                <td>2.45-2.48</td>
                <td>0.843-0.880</td>
                <td>71-73%</td>
                <td>1.5x</td>
                <td><strong>Catastr√≥fico - perdeu ~73% dos incrementos</strong></td>
            </tr>
            <tr style="background-color: #fff9e6;">
                <td>Critical</td>
                <td>21.3381</td>
                <td>3.141593</td>
                <td>0.000%</td>
                <td>0.17x</td>
                <td>Correto, mas <strong>5.9x mais lento</strong></td>
            </tr>
            <tr style="background-color: #e6f7e6;">
                <td>Reestruturado</td>
                <td>0.9039</td>
                <td>3.141587</td>
                <td>0.000%</td>
                <td>4.0x</td>
                <td><strong>Melhor performance com 4 threads</strong></td>
            </tr>
        </table>
        
        <h2>Demonstra√ß√µes Detalhadas das Cl√°usulas OpenMP</h2>
        
        <div class="clause-grid">
            <div class="clause-card">
                <h4>PRIVATE</h4>
                <p><strong>Comportamento:</strong> Cada thread tem sua pr√≥pria c√≥pia</p>
                <ul>
                    <li><strong>Valor inicial √© INDEFINIDO</strong></li>
                    <li>Modifica√ß√µes n√£o afetam outras threads</li>
                    <li>Valor n√£o √© preservado ap√≥s regi√£o paralela</li>
                </ul>
                <div class="code-block" style="font-size: 13px; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-left: 4px solid #6c757d;">
                    <div style="background: #343a40; color: white; padding: 8px; border-radius: 4px; margin-bottom: 10px; font-weight: bold;">
                        üîí DEMONSTRA√á√ÉO: PRIVATE
                    </div>
                    <div style="background: #fff3cd; padding: 8px; border-radius: 4px; margin-bottom: 8px;">
                        <strong style="color: #856404;">‚¨áÔ∏è ANTES:</strong> variavel = 100
                    </div>
                    <div style="background: #d1ecf1; padding: 10px; border-radius: 4px; margin-bottom: 8px;">
                        <strong style="color: #0c5460;">üßµ DURANTE A EXECU√á√ÉO:</strong><br>
                        <span style="color: #d32f2f;">Thread 0:</span> variavel = ???<br>
                        <span style="color: #388e3c;">Thread 1:</span> variavel = ???<br>
                        <span style="color: #f57c00;">Thread 2:</span> variavel = ???<br>
                        <span style="color: #7b1fa2;">Thread 3:</span> variavel = ???<br>
                        <small style="color: #6c757d;">üí° Cada thread tem sua c√≥pia, valor inicial indefinido</small>
                    </div>
                    <div style="background: #f8d7da; padding: 8px; border-radius: 4px;">
                        <strong style="color: #721c24;">‚¨ÜÔ∏è DEPOIS:</strong> variavel = 100 (inalterada)
                    </div>
                </div>
            </div>
            
            <div class="clause-card">
                <h4>FIRSTPRIVATE</h4>
                <p><strong>Comportamento:</strong> Como private, mas inicializada</p>
                <ul>
                    <li><strong>Cada thread recebe C√ìPIA do valor inicial</strong></li>
                    <li>√ötil quando threads precisam do valor original</li>
                    <li>Modifica√ß√µes locais n√£o afetam vari√°vel original</li>
                </ul>
                <div class="code-block" style="font-size: 13px; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-left: 4px solid #28a745;">
                    <div style="background: #28a745; color: white; padding: 8px; border-radius: 4px; margin-bottom: 10px; font-weight: bold;">
                        üéØ DEMONSTRA√á√ÉO: FIRSTPRIVATE
                    </div>
                    <div style="background: #fff3cd; padding: 8px; border-radius: 4px; margin-bottom: 8px;">
                        <strong style="color: #856404;">‚¨áÔ∏è ANTES:</strong> contador = 50
                    </div>
                    <div style="background: #d4edda; padding: 10px; border-radius: 4px; margin-bottom: 8px;">
                        <strong style="color: #155724;">üßµ DURANTE A EXECU√á√ÉO:</strong><br>
                        <span style="color: #d32f2f;">Thread 0:</span> contador = 50 ‚Üí 60<br>
                        <span style="color: #388e3c;">Thread 1:</span> contador = 50 ‚Üí 75<br>
                        <span style="color: #f57c00;">Thread 2:</span> contador = 50 ‚Üí 55<br>
                        <span style="color: #7b1fa2;">Thread 3:</span> contador = 50 ‚Üí 65<br>
                        <small style="color: #6c757d;">üí° Todas come√ßam com 50, modificam independentemente</small>
                    </div>
                    <div style="background: #d1ecf1; padding: 8px; border-radius: 4px;">
                        <strong style="color: #0c5460;">‚¨ÜÔ∏è DEPOIS:</strong> contador = 50 (inalterada)
                    </div>
                </div>
            </div>
            
            <div class="clause-card">
                <h4>SHARED</h4>
                <p><strong>Comportamento:</strong> Vari√°vel compartilhada entre threads</p>
                <ul>
                    <li><strong>Todas threads acessam mesma mem√≥ria</strong></li>
                    <li>Requer sincroniza√ß√£o (#pragma omp atomic, critical)</li>
                    <li>Padr√£o para vari√°veis globais</li>
                </ul>
                <div class="code-block" style="font-size: 13px; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-left: 4px solid #ffc107;">
                    <div style="background: #ffc107; color: #212529; padding: 8px; border-radius: 4px; margin-bottom: 10px; font-weight: bold;">
                        ü§ù DEMONSTRA√á√ÉO: SHARED
                    </div>
                    <div style="background: #fff3cd; padding: 8px; border-radius: 4px; margin-bottom: 8px;">
                        <strong style="color: #856404;">‚¨áÔ∏è ANTES:</strong> soma_total = 0
                    </div>
                    <div style="background: #fff3e0; padding: 10px; border-radius: 4px; margin-bottom: 8px;">
                        <strong style="color: #ef6c00;">üßµ ACESSOS SIMULT√ÇNEOS:</strong><br>
                        <span style="color: #d32f2f;">Thread 0:</span> soma_total += 10 ‚Üí 10<br>
                        <span style="color: #388e3c;">Thread 1:</span> soma_total += 20 ‚Üí 30<br>
                        <span style="color: #f57c00;">Thread 2:</span> soma_total += 15 ‚Üí 45<br>
                        <span style="color: #7b1fa2;">Thread 3:</span> soma_total += 25 ‚Üí 70<br>
                        <small style="color: #dc3545;">‚ö†Ô∏è Requer sincroniza√ß√£o!</small>
                    </div>
                    <div style="background: #d4edda; padding: 8px; border-radius: 4px;">
                        <strong style="color: #155724;">‚¨ÜÔ∏è DEPOIS:</strong> soma_total = 70
                    </div>
                </div>
            </div>
            
            <div class="clause-card">
                <h4>LASTPRIVATE</h4>
                <p><strong>Comportamento:</strong> Preserva valor da √∫ltima itera√ß√£o</p>
                <ul>
                    <li><strong>Thread que executa √∫ltima itera√ß√£o define valor</strong></li>
                    <li>Valor √© copiado de volta para vari√°vel original</li>
                    <li>√ötil para capturar resultado final de loops</li>
                </ul>
                <div class="code-block" style="font-size: 13px; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-left: 4px solid #dc3545;">
                    <div style="background: #dc3545; color: white; padding: 8px; border-radius: 4px; margin-bottom: 10px; font-weight: bold;">
                        üèÅ DEMONSTRA√á√ÉO: LASTPRIVATE
                    </div>
                    <div style="background: #fff3cd; padding: 8px; border-radius: 4px; margin-bottom: 8px;">
                        <strong style="color: #856404;">‚¨áÔ∏è ANTES:</strong> ultimo_valor = -1
                    </div>
                    <div style="background: #fce4ec; padding: 10px; border-radius: 4px; margin-bottom: 8px;">
                        <strong style="color: #ad1457;">üßµ LOOP for (i=0; i&lt;100; i++):</strong><br>
                        <span style="color: #666;">Thread 0:</span> i=0..24 ‚Üí ultimo_valor=24<br>
                        <span style="color: #666;">Thread 1:</span> i=25..49 ‚Üí ultimo_valor=49<br>
                        <span style="color: #666;">Thread 2:</span> i=50..74 ‚Üí ultimo_valor=74<br>
                        <span style="color: #1976d2; font-weight: bold;">Thread 3:</span> i=75..99 ‚Üí ultimo_valor=99 üèÜ
                    </div>
                    <div style="background: #d4edda; padding: 8px; border-radius: 4px;">
                        <strong style="color: #155724;">‚¨ÜÔ∏è DEPOIS:</strong> ultimo_valor = 99<br>
                        <small style="color: #6c757d;">üí° Thread 3 executou a √∫ltima itera√ß√£o</small>
                    </div>
                </div>
            </div>
        </div>

        <h3>Performance das Cl√°usulas OpenMP (250 Milh√µes de Pontos)</h3>
        <table>
            <tr>
                <th>Cl√°usula</th>
                <th>Tempo (s)</th>
                <th>œÄ Estimado</th>
                <th>Erro (%)</th>
                <th>Speedup vs Sequencial</th>
                <th>Caracter√≠sticas Principais</th>
            </tr>
            <tr style="background-color: #e8f5e8;">
                <td><strong>PRIVATE</strong></td>
                <td>0.9532</td>
                <td>3.141587</td>
                <td>0.000%</td>
                <td><strong>3.8x</strong></td>
                <td>Quase igual ao reestruturado - Inicializa√ß√£o manual</td>
            </tr>
            <tr style="background-color: #e8f5e8;">
                <td><strong>LASTPRIVATE</strong></td>
                <td>1.0889</td>
                <td>3.141587</td>
                <td>0.000%</td>
                <td><strong>3.3x</strong></td>
                <td>Performance excelente - Preserva √∫ltima itera√ß√£o</td>
            </tr>
            <tr style="background-color: #e8f5e8;">
                <td><strong>FIRSTPRIVATE</strong></td>
                <td>1.0608</td>
                <td>3.141548</td>
                <td>0.001%</td>
                <td><strong>3.4x</strong></td>
                <td>Overhead moderado - Copia automaticamente</td>
            </tr>
            <tr style="background-color: #ffe6e6;">
                <td><strong>SHARED</strong></td>
                <td>7.3141</td>
                <td>3.141587</td>
                <td>0.000%</td>
                <td><strong>0.49x</strong></td>
                <td><strong>Mais lenta que sequencial!</strong> - Atomic mata performance</td>
            </tr>
        </table>

        <div class="solution">
            <strong>üéØ Por que apenas SHARED √© lenta?</strong><br><br>
            
            <strong>üìä Compara√ß√£o com a Vers√£o Reestruturada (0.9039s):</strong><br>
            ‚Ä¢ <strong>PRIVATE (0.9532s):</strong> Quase id√™ntica - diferen√ßa de apenas 49ms<br>
            ‚Ä¢ <strong>FIRSTPRIVATE (1.0608s):</strong> Overhead m√≠nimo - diferen√ßa de 157ms<br>
            ‚Ä¢ <strong>LASTPRIVATE (1.0889s):</strong> Overhead pequeno - diferen√ßa de 185ms<br>
            ‚Ä¢ <strong>SHARED (7.3141s):</strong> ‚ö†Ô∏è <strong>CATASTR√ìFICA</strong> - 7.7x mais lenta!<br><br>
            
            <strong>üîç Explica√ß√£o T√©cnica:</strong><br><br>
            
            <strong>‚úÖ PRIVATE, FIRSTPRIVATE e LASTPRIVATE:</strong><br>
            ‚Ä¢ Fazem <strong>acumula√ß√£o local</strong> (igual ao reestruturado)<br>
            ‚Ä¢ Cada thread conta seus pontos em vari√°vel <strong>privada</strong><br>
            ‚Ä¢ Sincroniza√ß√£o acontece apenas <strong>1x por thread</strong> (4 vezes total)<br>
            ‚Ä¢ Resultado: <strong>Performance quase √≥tima</strong><br><br>
            
            <strong>‚ùå SHARED com Atomic:</strong><br>
            ‚Ä¢ Usa <code>contador_compartilhado</code> com <code>#pragma omp atomic</code><br>
            ‚Ä¢ <strong>Sincroniza√ß√£o a CADA itera√ß√£o</strong> (250 milh√µes de vezes!)<br>
            ‚Ä¢ Threads competem pelo mesmo contador a cada ponto processado<br>
            ‚Ä¢ Resultado: <strong>Overhead de sincroniza√ß√£o mata a performance</strong><br><br>
            
            <strong>üí° Conclus√£o:</strong> SHARED √© lenta porque for√ßa sincroniza√ß√£o massiva, enquanto as outras cl√°usulas mant√™m o padr√£o eficiente de acumula√ß√£o local do reestruturado.
        </div>

        <h2>Dica de Boas Pr√°ticas: <code>default(none)</code> no OpenMP</h2>
        <div class="warning">
            <strong>Por que usar <code>default(none)</code>?</strong><br>
            Em programas OpenMP complexos, pode ser dif√≠cil acompanhar o escopo de cada vari√°vel (se √© <code>shared</code>, <code>private</code>, etc).<br>
            Ao adicionar <code>default(none)</code> na diretiva <code>parallel</code>, voc√™ obriga o compilador a exigir que todas as vari√°veis usadas dentro do bloco tenham seu escopo explicitamente declarado.<br>
            <ul>
                <li>Ajuda a evitar bugs sutis de paralelismo.</li>
                <li>Torna o c√≥digo mais leg√≠vel e seguro.</li>
                <li>Exemplo: <code>#pragma omp parallel for default(none) private(i) shared(N, array)</code></li>
            </ul>
            <strong>Recomenda√ß√£o:</strong> Sempre que poss√≠vel, utilize <code>default(none)</code> em projetos reais para garantir clareza e seguran√ßa no escopo das vari√°veis.
        </div>
        <h2>An√°lise dos Resultados</h2>
        
        <h3>Observa√ß√µes Cr√≠ticas (250 Milh√µes de Pontos - Execu√ß√£o Atualizada)</h3>
        <ol>
            <li><strong>Condi√ß√£o de Corrida Catastr√≥fica:</strong> A vers√£o incorreta com `#pragma omp parallel for` apresenta erros extremos (71-73%), perdendo ~73% dos incrementos e tornando o programa completamente in√∫til.</li>
            
            <li><strong>Critical Section - Gargalo Extremo:</strong> A corre√ß√£o com `#pragma omp critical` funciona, mas √© 5.9x mais lenta que a vers√£o sequencial (21.3s vs 3.6s) devido √† sincroniza√ß√£o excessiva.</li>
            
            <li><strong>Reestrutura√ß√£o Bem-Sucedida:</strong> A abordagem com `#pragma omp parallel` + `#pragma omp for` e acumula√ß√£o local consegue speedup excepcional de **4.0x** (0.9039s vs 3.6101s), demonstrando paraleliza√ß√£o eficiente.</li>
            
            <li><strong>Cl√°usulas com Dataset Completo:</strong> Todas as demonstra√ß√µes das cl√°usulas usam o dataset completo (250M pontos), confirmando comportamento correto e revelando diferen√ßas sutis de performance entre elas.</li>
            
            <li><strong>Performance Ranking:</strong> PRIVATE (0.95s) ‚âà REESTRUTURADO (0.90s) > FIRSTPRIVATE (1.06s) > LASTPRIVATE (1.09s) >> SHARED (7.31s)</li>
        </ol>
        
        <h3>Li√ß√µes Aprendidas sobre Cl√°usulas OpenMP</h3>
        <ul>
            <li><strong>PRIVATE:</strong> Ideal para vari√°veis tempor√°rias que n√£o precisam de valor inicial espec√≠fico</li>
            <li><strong>FIRSTPRIVATE:</strong> Essencial quando threads precisam come√ßar com valor conhecido</li>
            <li><strong>SHARED:</strong> Requer cuidado extremo com sincroniza√ß√£o (#pragma omp atomic, critical)</li>
            <li><strong>LASTPRIVATE:</strong> √ötil para capturar estados finais de loops paralelos</li>
        </ul>
        
        <h2>Conclus√µes</h2>
        <ol>
            <li><strong>Condi√ß√µes de corrida</strong> s√£o um problema cr√≠tico na paraleliza√ß√£o que pode levar a resultados completamente incorretos (erros de 70-72% observados com dataset grande)</li>
            <li><strong>Critical sections</strong> resolvem o problema mas introduzem overhead extremo (6x mais lento que sequencial com 196M sincroniza√ß√µes)</li>
            <li><strong>Reestrutura√ß√£o inteligente</strong> √© fundamental - separar `#pragma omp parallel` de `#pragma omp for` permitiu speedup de 2.8x com 4 threads</li>
            <li><strong>Escalabilidade confirmada</strong> - Com datasets grandes, a diferen√ßa entre abordagens corretas e incorretas fica ainda mais evidente</li>
            <li><strong>Cl√°usulas OpenMP</strong> oferecem controle preciso sobre o escopo de vari√°veis:
                <ul>
                    <li>Use <code>private</code> para vari√°veis tempor√°rias que n√£o precisam de valor inicial</li>
                    <li>Use <code>firstprivate</code> quando threads precisam come√ßar com valor conhecido</li>
                    <li>Use <code>lastprivate</code> para capturar resultado da √∫ltima itera√ß√£o</li>
                    <li>Use <code>shared</code> para dados compartilhados (requer sincroniza√ß√£o cuidadosa)</li>
                    <li>Use <code>default(none)</code> para garantir controle expl√≠cito de todas as vari√°veis</li>
                </ul>
            </li>
        </ol>
        
       
            <img src="tarefa6.png" alt="Gr√°fico de Performance - Tarefa 6 Monte Carlo OpenMP" style="max-width: 100%; height: auto; border: 1px solid #ccc; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
        </div>
    </div>
</body>
</html>
