<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tarefa 8: Estimativa Estoc√°stica de œÄ com OpenMP</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c5aa0;
            border-bottom: 3px solid #2c5aa0;
            padding-bottom: 10px;
            text-align: center;
        }
        h2 {
            color: #34495e;
            border-left: 4px solid #3498db;
            padding-left: 15px;
            margin-top: 30px;
        }
        h3 {
            color: #2c3e50;
            margin-top: 25px;
        }
        h4 {
            color: #7f8c8d;
            margin-top: 20px;
        }
        code {
            background-color: #f8f9fa;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #e74c3c;
        }
        pre {
            background-color: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 15px 0;
            border-left: 4px solid #3182ce;
        }
        pre code {
            background-color: transparent;
            color: inherit;
            padding: 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background-color: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #3498db;
            color: white;
            font-weight: bold;
        }
        tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        tr:hover {
            background-color: #e8f4f8;
        }
        .highlight {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
        }
        .success {
            color: #27ae60;
            font-weight: bold;
        }
        .warning {
            color: #e67e22;
            font-weight: bold;
        }
        .error {
            color: #e74c3c;
            font-weight: bold;
        }
        .emoji {
            font-size: 1.2em;
        }
        .math {
            font-style: italic;
            background-color: #f0f8ff;
            padding: 10px;
            border-left: 3px solid #4a90e2;
            margin: 10px 0;
        }
        .cache-discussion {
            background-color: #f8f9fa;
            border: 2px solid #6f42c1;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        .cache-discussion h3 {
            color: #6f42c1;
            margin-top: 0;
        }
        .code-image {
            text-align: center;
            margin: 30px 0;
        }
        .code-image img {
            max-width: 100%;
            height: auto;
            border: 2px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        ul li {
            margin-bottom: 8px;
        }
        .algorithm-box {
            background-color: #e8f5e8;
            border: 1px solid #4caf50;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1> Tarefa 8: Coer√™ncia de Cache e Falso Compartilhamento</h1>

        <h2><span class="emoji">üìã</span> Descri√ß√£o do Problema</h2>
        <p>Este projeto implementa quatro vers√µes diferentes de estimativa estoc√°stica de œÄ usando o m√©todo de Monte Carlo com paraleliza√ß√£o OpenMP. O objetivo √© comparar diferentes estrat√©gias de sincroniza√ß√£o e geradores de n√∫meros aleat√≥rios.</p>

        <h2><span class="emoji">üéØ</span> Objetivos</h2>
        <ol>
            <li><strong>Implementar estimativa de œÄ</strong> usando m√©todo de Monte Carlo</li>
            <li><strong>Comparar estrat√©gias de sincroniza√ß√£o</strong>:
                <ul>
                    <li>Regi√£o cr√≠tica (<code>#pragma omp critical</code>)</li>
                    <li>Vetoriza√ß√£o (cada thread escreve em posi√ß√£o pr√≥pria)</li>
                </ul>
            </li>
            <li><strong>Comparar geradores de n√∫meros aleat√≥rios</strong>:
                <ul>
                    <li><code>rand()</code> (n√£o thread-safe)</li>
                    <li><code>rand_r()</code> (thread-safe)</li>
                </ul>
            </li>
        </ol>

        <h2><span class="emoji">üßÆ</span> Teoria: M√©todo de Monte Carlo para œÄ</h2>

        <h3>Fundamento Matem√°tico</h3>
        <p>O m√©todo utiliza a rela√ß√£o entre a √°rea de um c√≠rculo e um quadrado:</p>
        <div class="math">
            √Årea do c√≠rculo = œÄ √ó r¬≤<br>
            √Årea do quadrado = (2r)¬≤<br><br>
            Raz√£o = œÄ √ó r¬≤ / (2r)¬≤ = œÄ/4
        </div>

        <h3>Algoritmo</h3>
        <div class="algorithm-box">
            <ol>
                <li>Gerar pontos aleat√≥rios (x,y) no intervalo [0,1]</li>
                <li>Verificar se o ponto est√° dentro do c√≠rculo: <code>x¬≤ + y¬≤ ‚â§ 1</code></li>
                <li>Contar quantos pontos est√£o dentro do c√≠rculo</li>
                <li>Estimar œÄ: <code>œÄ ‚âà 4 √ó (pontos_dentro / total_pontos)</code></li>
            </ol>
        </div>

        <h2><span class="emoji">üîß</span> Implementa√ß√µes</h2>

        <h3>Vers√£o 1: <code>rand()</code> + Regi√£o Cr√≠tica</h3>
        <pre><code>#pragma omp parallel num_threads(nthreads)
{
    long long int acertos_priv = 0;
    #pragma omp for
    for (long long int i = 0; i < N; i++) {
        double x = (double)rand() / RAND_MAX;
        double y = (double)rand() / RAND_MAX;
        if (x*x + y*y <= 1.0) acertos_priv++;
    }
    #pragma omp critical
    acertos += acertos_priv;
}</code></pre>

        <p><strong>Caracter√≠sticas:</strong></p>
        <ul>
            <li><span class="success">‚úÖ</span> Cada thread acumula em vari√°vel privada</li>
            <li><span class="success">‚úÖ</span> Sincroniza√ß√£o por regi√£o cr√≠tica</li>
            <li><span class="error">‚ùå</span> <code>rand()</code> n√£o √© thread-safe</li>
            <li><span class="error">‚ùå</span> Poss√≠vel conten√ß√£o na regi√£o cr√≠tica</li>
        </ul>

        <h3>Vers√£o 2: <code>rand()</code> + Vetor Compartilhado</h3>
        <pre><code>#pragma omp parallel num_threads(nthreads)
{
    int tid = omp_get_thread_num();
    long long int acertos_priv = 0;
    #pragma omp for
    for (long long int i = 0; i < N; i++) {
        double x = (double)rand() / RAND_MAX;
        double y = (double)rand() / RAND_MAX;
        if (x*x + y*y <= 1.0) acertos_priv++;
    }
    acertos_vet[tid] = acertos_priv;
}
// Soma serial ap√≥s regi√£o paralela
for (int i = 0; i < nthreads; i++) acertos_total += acertos_vet[i];</code></pre>

        <p><strong>Caracter√≠sticas:</strong></p>
        <ul>
            <li><span class="success">‚úÖ</span> Elimina conten√ß√£o (cada thread escreve em posi√ß√£o pr√≥pria)</li>
            <li><span class="success">‚úÖ</span> Soma serial ap√≥s paraleliza√ß√£o</li>
            <li><span class="error">‚ùå</span> <code>rand()</code> n√£o √© thread-safe</li>
            <li><span class="success">‚úÖ</span> Melhor escalabilidade</li>
        </ul>

        <h3>Vers√£o 3: <code>rand_r()</code> + Regi√£o Cr√≠tica</h3>
        <pre><code>#pragma omp parallel num_threads(nthreads)
{
    unsigned int seed = (unsigned int)time(NULL) ^ omp_get_thread_num();
    long long int acertos_priv = 0;
    #pragma omp for
    for (long long int i = 0; i < N; i++) {
        double x = (double)rand_r(&seed) / RAND_MAX;
        double y = (double)rand_r(&seed) / RAND_MAX;
        if (x*x + y*y <= 1.0) acertos_priv++;
    }
    #pragma omp critical
    acertos += acertos_priv;
}</code></pre>

        <p><strong>Caracter√≠sticas:</strong></p>
        <ul>
            <li><span class="success">‚úÖ</span> <code>rand_r()</code> √© thread-safe</li>
            <li><span class="success">‚úÖ</span> Cada thread tem seu pr√≥prio seed</li>
            <li><span class="warning">‚ùå</span> Poss√≠vel conten√ß√£o na regi√£o cr√≠tica</li>
            <li><span class="success">‚úÖ</span> Gera√ß√£o de n√∫meros aleat√≥rios correta</li>
        </ul>

        <h3>Vers√£o 4: <code>rand_r()</code> + Vetor Compartilhado</h3>
        <pre><code>#pragma omp parallel num_threads(nthreads)
{
    int tid = omp_get_thread_num();
    unsigned int seed = (unsigned int)time(NULL) ^ tid;
    long long int acertos_priv = 0;
    #pragma omp for
    for (long long int i = 0; i < N; i++) {
        double x = (double)rand_r(&seed) / RAND_MAX;
        double y = (double)rand_r(&seed) / RAND_MAX;
        if (x*x + y*y <= 1.0) acertos_priv++;
    }
    acertos_vet[tid] = acertos_priv;
}</code></pre>

        <p><strong>Caracter√≠sticas:</strong></p>
        <ul>
            <li><span class="success">‚úÖ</span> <code>rand_r()</code> √© thread-safe</li>
            <li><span class="success">‚úÖ</span> Elimina conten√ß√£o</li>
            <li><span class="success">‚úÖ</span> Melhor escalabilidade</li>
            <li><span class="success">‚úÖ</span> Implementa√ß√£o mais robusta</li>
        </ul>

        <h2><span class="emoji">üìä</span> Resultados Experimentais</h2>

        <h3>Configura√ß√£o do Teste</h3>
        <ul>
            <li><strong>Pontos:</strong> 100.000.000</li>
            <li><strong>Threads:</strong> 4</li>
            <li><strong>Compilador:</strong> GCC com <code>-fopenmp</code></li>
        </ul>

        <h3>Tempos de Execu√ß√£o</h3>
        <table>
            <thead>
                <tr>
                    <th>Vers√£o</th>
                    <th>Gerador</th>
                    <th>Sincroniza√ß√£o</th>
                    <th>Tempo (s)</th>
                    <th>œÄ Estimado</th>
                    <th>Speedup</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>1</td>
                    <td><code>rand()</code></td>
                    <td>Critical</td>
                    <td>~18.0</td>
                    <td>3.1416653</td>
                    <td>1.0x</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td><code>rand()</code></td>
                    <td>Vetor</td>
                    <td>~17.4</td>
                    <td>3.1413922</td>
                    <td>1.03x</td>
                </tr>
                <tr style="background-color: #d4edda;">
                    <td>3</td>
                    <td><code>rand_r()</code></td>
                    <td>Critical</td>
                    <td>~0.48</td>
                    <td>3.1416518</td>
                    <td>37.5x</td>
                </tr>
                <tr style="background-color: #d1ecf1;">
                    <td>4</td>
                    <td><code>rand_r()</code></td>
                    <td>Vetor</td>
                    <td>~0.44</td>
                    <td>3.1416518</td>
                    <td>40.9x</td>
                </tr>
            </tbody>
        </table>

        <h3>An√°lise dos Resultados</h3>

        <h4><span class="emoji">üöÄ</span> Performance Dram√°tica com <code>rand_r()</code></h4>
        <ul>
            <li><strong>37-40x speedup</strong> ao trocar <code>rand()</code> por <code>rand_r()</code></li>
            <li>Diferen√ßa n√£o √© apenas thread-safety, mas conten√ß√£o interna</li>
        </ul>

        <h4><span class="emoji">üîí</span> Impacto da Sincroniza√ß√£o</h4>
        <ul>
            <li>Diferen√ßa pequena entre critical e vetor (~8% melhoria)</li>
            <li>Vetor compartilhado tem vantagem em escalabilidade</li>
        </ul>

        <h4><span class="emoji">üé≤</span> Thread-Safety dos Geradores</h4>
        <ul>
            <li><code>rand()</code>: Usa estado global compartilhado ‚Üí conten√ß√£o severa</li>
            <li><code>rand_r()</code>: Estado local por thread ‚Üí paralelismo real</li>
        </ul>

        <div class="cache-discussion">
            <h2><span class="emoji">üß†</span> An√°lise de Coer√™ncia de Cache e Falso Compartilhamento</h2>
            
            <h3>Comportamento dos Geradores de N√∫meros Aleat√≥rios</h3>
            
            <h4><code>rand()</code> - Conten√ß√£o Extrema</h4>
            <p>A fun√ß√£o <code>rand()</code> utiliza um estado global compartilhado entre todas as threads. Isso causa:</p>
            <ul>
                <li><strong>Mutex interno:</strong> Cada chamada de <code>rand()</code> adquire um lock global</li>
                <li><strong>Serializa√ß√£o completa:</strong> Apenas uma thread pode gerar n√∫meros por vez</li>
                <li><strong>Cache thrashing:</strong> Constante invalida√ß√£o da linha de cache contendo o estado</li>
                <li><strong>Conten√ß√£o de mem√≥ria:</strong> Todas as threads competem pelo mesmo endere√ßo de mem√≥ria</li>
            </ul>
            
            <div class="highlight">
                <strong>Resultado:</strong> Mesmo com 4 threads, o programa roda essencialmente em modo serial devido √† conten√ß√£o no gerador de n√∫meros aleat√≥rios, explicando os tempos de ~17-18 segundos.
            </div>

            <h4><code>rand_r()</code> - Paralelismo Real</h4>
            <p>A fun√ß√£o <code>rand_r()</code> permite que cada thread mantenha seu pr√≥prio estado:</p>
            <ul>
                <li><strong>Estado local:</strong> Cada thread tem sua vari√°vel <code>seed</code> privada</li>
                <li><strong>Cache locality:</strong> O seed fica na cache L1 da thread, evitando acessos √† mem√≥ria</li>
                <li><strong>Paralelismo verdadeiro:</strong> Threads operam independentemente</li>
                <li><strong>Aus√™ncia de conten√ß√£o:</strong> N√£o h√° compartilhamento de dados entre threads durante a gera√ß√£o</li>
            </ul>

            <h3>Estrat√©gias de Sincroniza√ß√£o e Cache</h3>
            
            <h4>Regi√£o Cr√≠tica (#pragma omp critical)</h4>
            <ul>
                <li><strong>Conten√ß√£o pontual:</strong> Apenas na soma final dos resultados</li>
                <li><strong>Baixo overhead:</strong> Regi√£o cr√≠tica √© executada apenas uma vez por thread</li>
                <li><strong>Cache coherence:</strong> Linha de cache da vari√°vel <code>acertos</code> √© invalidada a cada update</li>
            </ul>

            <h4>Vetor Compartilhado</h4>
            <ul>
                <li><strong>Falso compartilhamento potencial:</strong> Se elementos do vetor estiverem na mesma linha de cache</li>
                <li><strong>Mitiga√ß√£o:</strong> Com 4 threads e <code>long long int</code> (8 bytes), elementos ficam em linhas diferentes</li>
                <li><strong>Acesso sequencial:</strong> A soma final beneficia da localidade espacial</li>
                <li><strong>Menor conten√ß√£o:</strong> Cada thread escreve em posi√ß√£o √∫nica, evitando invalida√ß√µes</li>
            </ul>

            <h3>An√°lise Detalhada por Vers√£o</h3>
            
            <div style="background-color: #fff2f2; padding: 15px; border-left: 4px solid #e74c3c; margin: 10px 0;">
                <h4>Vers√µes 1 e 2 (rand()): ~17-18s</h4>
                <p><strong>Gargalo dominante:</strong> Serializa√ß√£o em <code>rand()</code></p>
                <ul>
                    <li>Diferen√ßa m√≠nima entre critical e vetor (17.4s vs 18.0s)</li>
                    <li>O overhead da sincroniza√ß√£o √© irrelevante comparado √† conten√ß√£o do <code>rand()</code></li>
                    <li>Cache miss rate alto devido ao mutex global</li>
                </ul>
            </div>

            <div style="background-color: #f2fff2; padding: 15px; border-left: 4px solid #27ae60; margin: 10px 0;">
                <h4>Vers√µes 3 e 4 (rand_r()): ~0.44-0.48s</h4>
                <p><strong>Paralelismo efetivo:</strong> Speedup de ~37-40x</p>
                <ul>
                    <li>Diferen√ßa pequena mas consistente entre critical e vetor (0.48s vs 0.44s)</li>
                    <li>Vetor tem ~8% melhor performance devido √† aus√™ncia de conten√ß√£o na sincroniza√ß√£o</li>
                    <li>Alta localidade de cache para o seed de cada thread</li>
                    <li>Paralelismo pr√≥ximo ao ideal (4x te√≥rico vs 37-40x observado indica overhead baixo)</li>
                </ul>
            </div>

            <h3>Implica√ß√µes para Escalabilidade</h3>
            <ul>
                <li><strong>Vers√µes 1-2:</strong> N√£o escalam devido √† serializa√ß√£o em <code>rand()</code></li>
                <li><strong>Vers√£o 3:</strong> Escal√°vel mas limitada pela regi√£o cr√≠tica em muitas threads</li>
                <li><strong>Vers√£o 4:</strong> Melhor escalabilidade, ideal para muitas threads</li>
            </ul>

            <div class="highlight">
                <strong>Conclus√£o chave:</strong> A escolha do gerador de n√∫meros aleat√≥rios tem impacto muito maior na performance do que a estrat√©gia de sincroniza√ß√£o, demonstrando a import√¢ncia cr√≠tica da coer√™ncia de cache em aplica√ß√µes paralelas.
            </div>
        </div>

        <h2><span class="emoji">üí°</span> Conclus√µes</h2>

        <h3>Li√ß√µes Aprendidas</h3>
        <ol>
            <li><strong>Thread-Safety √© Crucial:</strong> A diferen√ßa entre <code>rand()</code> e <code>rand_r()</code> domina completamente a performance</li>
            <li><strong>Conten√ß√£o Interna:</strong> <code>rand()</code> tem mutex interno que serializa execu√ß√£o</li>
            <li><strong>Estrat√©gia de Sincroniza√ß√£o:</strong> Vetor compartilhado √© ligeiramente melhor que regi√£o cr√≠tica</li>
            <li><strong>Escalabilidade:</strong> Vers√£o 4 (<code>rand_r()</code> + vetor) √© a mais escal√°vel</li>
        </ol>

        <h3>Recomenda√ß√µes</h3>
        <ul>
            <li><strong>Use sempre <code>rand_r()</code></strong> em c√≥digo paralelo</li>
            <li><strong>Prefira vetoriza√ß√£o</strong> para reduzir conten√ß√£o</li>
            <li><strong>Inicialize seeds √∫nicos</strong> por thread</li>
            <li><strong>Me√ßa performance</strong> de diferentes estrat√©gias</li>
        </ul>

        <h2><span class="emoji">üìö</span> Conceitos Importantes</h2>

        <h3>OpenMP</h3>
        <ul>
            <li><strong><code>#pragma omp parallel</code>:</strong> Cria regi√£o paralela</li>
            <li><strong><code>#pragma omp for</code>:</strong> Distribui itera√ß√µes entre threads</li>
            <li><strong><code>#pragma omp critical</code>:</strong> Se√ß√£o cr√≠tica (acesso exclusivo)</li>
            <li><strong><code>omp_get_thread_num()</code>:</strong> ID da thread atual</li>
        </ul>

        <h3>Thread-Safety</h3>
        <ul>
            <li><strong>Thread-safe:</strong> Fun√ß√£o pode ser chamada simultaneamente por m√∫ltiplas threads</li>
            <li><strong>Race condition:</strong> Resultado depende da ordem de execu√ß√£o das threads</li>
            <li><strong>Conten√ß√£o:</strong> Threads competem por mesmo recurso</li>
        </ul>

        <h3>Estrat√©gias de Redu√ß√£o</h3>
        <ul>
            <li><strong>Critical section:</strong> Serializa acesso a vari√°vel compartilhada</li>
            <li><strong>Private accumulation:</strong> Cada thread acumula localmente, depois combina</li>
            <li><strong>Array indexing:</strong> Cada thread escreve em posi√ß√£o √∫nica</li>
        </ul>

        <div class="code-image">
            <h2><span class="emoji">üíª</span> C√≥digo Fonte</h2>
            <img src="tarefa8.png" alt="C√≥digo fonte da Tarefa 8" title="Implementa√ß√£o completa das 4 vers√µes do algoritmo Monte Carlo">
            <p><em>Implementa√ß√£o completa das quatro vers√µes do algoritmo Monte Carlo para estimativa de œÄ</em></p>
        </div>

        <hr style="margin: 40px 0; border: none; border-top: 2px solid #eee;">
        <p style="text-align: center; color: #7f8c8d; font-style: italic;">
            <em>Este projeto demonstra conceitos fundamentais de programa√ß√£o paralela, thread-safety e otimiza√ß√£o de performance em aplica√ß√µes cient√≠ficas.</em>
        </p>
    </div>
</body>
</html>
