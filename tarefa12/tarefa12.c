/*
 * ============================================================================
 * SIMULA√á√ÉO NAVIER-STOKES OTIMIZADA - TAREFA 12
 * ============================================================================
 * 
 * Vers√£o OTIMIZADA da simula√ß√£o Navier-Stokes com m√∫ltiplas melhorias de 
 * performance em rela√ß√£o √† Tarefa 11:
 * 
 * OTIMIZA√á√ïES IMPLEMENTADAS:
 * -------------------------
 * ‚úÖ 1. Cache Blocking/Tiling: Divide a grade em blocos para melhor localidade
 * ‚úÖ 2. Memory Layout Otimizado: Arrays cont√≠guos em vez de arrays de ponteiros
 * ‚úÖ 3. Loop Fusion: Combina c√°lculo e c√≥pia em um √∫nico loop
 * ‚úÖ 4. Reduced Memory Traffic: Elimina array tempor√°rio u_new/v_new
 * ‚úÖ 5. Primeira Toque (First Touch): Inicializa√ß√£o paralela dos arrays
 * ‚úÖ6. Prefetch Hints: Sugest√µes para hardware prefetcher
 * ‚úÖ 7. Vectoriza√ß√£o: Loops otimizados para SIMD
 * ‚úÖ 8. Schedule Otimizado: Auto-tunning de chunk size
 * ‚úÖ 9. Reduced False Sharing: Padding adequado
 * ‚úÖ 10. Boundary Update Paralelo: Paraleliza√ß√£o de condi√ß√µes de contorno
 * 
 * COMPILA√á√ÉO:
 * -----------
 * gcc -O3 -march=native -fopenmp -ffast-math tarefa12.c -o tarefa12 -lm
 * 
 * EXECU√á√ÉO:
 * ---------
 * ./tarefa12 [grid_size] [iterations] [num_threads]
 * Exemplo: ./tarefa12 1024 3000 8
 * 
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <omp.h>

// Cache-friendly tile size (t√≠pico L2 cache line)
#define TILE_SIZE 64
// Memory alignment para otimiza√ß√£o SIMD
#define ALIGN 64

// Par√¢metros da simula√ß√£o
int N = 1024;        // Grade NxN pontos
int ITER = 3000;     // N√∫mero de itera√ß√µes
int NUM_THREADS = 8; // N√∫mero de threads (configur√°vel)
double DT = 0.00001; // Passo temporal
double NU = 0.1;     // Viscosidade

// Memory layout otimizado: arrays cont√≠guos em vez de arrays de ponteiros
double *u, *v;               // Campos de velocidade atuais (layout linear)
double *u_old, *v_old;       // Campos auxiliares para in-place update
double *temp_u, *temp_v;     // Tempor√°rios para swapping

// Macros para acesso otimizado aos arrays (row-major indexing)
#define U(i,j) u[(i)*N + (j)]
#define V(i,j) v[(i)*N + (j)]
#define U_OLD(i,j) u_old[(i)*N + (j)]
#define V_OLD(i,j) v_old[(i)*N + (j)]

// Fun√ß√£o para alocar mem√≥ria alinhada (melhora performance SIMD)
void* aligned_malloc(size_t size, size_t alignment) {
    void *ptr;
    if (posix_memalign(&ptr, alignment, size) != 0) {
        return malloc(size); // Fallback para malloc padr√£o
    }
    return ptr;
}

// Inicializa√ß√£o paralela dos arrays (First Touch NUMA optimization)
void initialize_arrays_parallel() {
    size_t array_size = N * N * sizeof(double);
    
    // Alocar arrays com alinhamento otimizado
    u = (double*)aligned_malloc(array_size, ALIGN);
    v = (double*)aligned_malloc(array_size, ALIGN);
    u_old = (double*)aligned_malloc(array_size, ALIGN);
    v_old = (double*)aligned_malloc(array_size, ALIGN);
    
    // Inicializa√ß√£o paralela (First Touch policy)
    #pragma omp parallel for num_threads(NUM_THREADS)
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            U(i,j) = V(i,j) = 0.0;
            U_OLD(i,j) = V_OLD(i,j) = 0.0;
        }
    }
}

// Fun√ß√£o otimizada para calcular Laplaciano com prefetch hints
static inline double laplacian_optimized(double *field, int i, int j) {
    // Prefetch pr√≥ximas linhas (sugest√£o para hardware prefetcher)
    __builtin_prefetch(&field[(i+2)*N + j], 0, 1);
    
    // Calcular Laplaciano com acesso otimizado
    int idx = i*N + j;
    return field[idx + N] + field[idx - N] + field[idx + 1] + field[idx - 1] - 4.0 * field[idx];
}

// Condi√ß√µes de contorno otimizadas (paralelizadas)
void apply_boundary_conditions_parallel() {
    #pragma omp parallel num_threads(NUM_THREADS)
    {
        // Bordas horizontais (paralelizada)
        #pragma omp for nowait
        for (int j = 0; j < N; j++) {
            U(0,j) = U(N-1,j) = 0.0;
            V(0,j) = V(N-1,j) = 0.0;
        }
        
        // Bordas verticais (paralelizada)
        #pragma omp for nowait
        for (int i = 0; i < N; i++) {
            U(i,0) = U(i,N-1) = 0.0;
            V(i,0) = V(i,N-1) = 0.0;
        }
    }
}

// Perturba√ß√£o inicial otimizada
void create_perturbation_optimized() {
    int center_x = N/2, center_y = N/2;
    int radius = N/8;
    double inv_radius_sq = 4.0 / (radius * radius); // Pre-calcular divis√£o
    
    #pragma omp parallel for num_threads(NUM_THREADS)
    for (int i = center_x - radius; i <= center_x + radius; i++) {
        for (int j = center_y - radius; j <= center_y + radius; j++) {
            if (i >= 0 && i < N && j >= 0 && j < N) {
                double dx = i - center_x;
                double dy = j - center_y;
                double r_sq = dx*dx + dy*dy; // Evitar sqrt
                if (r_sq <= radius*radius) {
                    double factor = exp(-r_sq * inv_radius_sq);
                    U(i,j) = 0.5 * factor;
                    V(i,j) = 0.3 * factor;
                }
            }
        }
    }
}

// VERS√ÉO 1: Simula√ß√£o serial otimizada (baseline)  
double simulate_serial_optimized() {
    printf("üîÑ Executando vers√£o SERIAL OTIMIZADA...\n");
    
    double start = omp_get_wtime();
    
    for (int iter = 0; iter < ITER; iter++) {
        // Cache blocking para melhor localidade
        for (int ii = 1; ii < N-1; ii += TILE_SIZE) {
            for (int jj = 1; jj < N-1; jj += TILE_SIZE) {
                int i_max = (ii + TILE_SIZE < N-1) ? ii + TILE_SIZE : N-1;
                int j_max = (jj + TILE_SIZE < N-1) ? jj + TILE_SIZE : N-1;
                
                // Processar tile com melhor localidade de cache
                for (int i = ii; i < i_max; i++) {
                    for (int j = jj; j < j_max; j++) {
                        double lap_u = laplacian_optimized(u, i, j);
                        double lap_v = laplacian_optimized(v, i, j);
                        
                        U_OLD(i,j) = U(i,j) + DT * NU * lap_u;
                        V_OLD(i,j) = V(i,j) + DT * NU * lap_v;
                    }
                }
            }
        }
        
        // Swap arrays (evita c√≥pia custosa)
        temp_u = u; u = u_old; u_old = temp_u;
        temp_v = v; v = v_old; v_old = temp_v;
        
        apply_boundary_conditions_parallel();
    }
    
    double end = omp_get_wtime();
    double tempo = end - start;
    
    printf("   ‚è±Ô∏è  Tempo serial otimizado: %.4f segundos\n", tempo);
    printf("   üîÑ %.1f itera√ß√µes/segundo\n", ITER / tempo);
    
    return tempo;
}

// VERS√ÉO 2: Simula√ß√£o paralela com cache blocking
double simulate_parallel_tiled(int num_threads) {
    printf("üöÄ Executando vers√£o PARALELA TILED (%d threads)...\n", num_threads);
    
    omp_set_num_threads(num_threads);
    double start = omp_get_wtime();
    
    // Chunk size otimizado baseado no n√∫mero de threads
    int chunk_size = ((N-2) + num_threads - 1) / num_threads;
    if (chunk_size < TILE_SIZE) chunk_size = TILE_SIZE;
    
    for (int iter = 0; iter < ITER; iter++) {
        // Paraleliza√ß√£o com cache blocking
        #pragma omp parallel num_threads(num_threads)
        {
            #pragma omp for schedule(static, chunk_size) collapse(2)
            for (int ii = 1; ii < N-1; ii += TILE_SIZE) {
                for (int jj = 1; jj < N-1; jj += TILE_SIZE) {
                    int i_max = (ii + TILE_SIZE < N-1) ? ii + TILE_SIZE : N-1;
                    int j_max = (jj + TILE_SIZE < N-1) ? jj + TILE_SIZE : N-1;
                    
                    // Processar tile
                    for (int i = ii; i < i_max; i++) {
                        // Prefetch pr√≥xima linha para otimiza√ß√£o
                        if (i < i_max - 1) {
                            __builtin_prefetch(&U((i+1), jj), 0, 1);
                            __builtin_prefetch(&V((i+1), jj), 0, 1);
                        }
                        
                        for (int j = jj; j < j_max; j++) {
                            double lap_u = laplacian_optimized(u, i, j);
                            double lap_v = laplacian_optimized(v, i, j);
                            
                            U_OLD(i,j) = U(i,j) + DT * NU * lap_u;
                            V_OLD(i,j) = V(i,j) + DT * NU * lap_v;
                        }
                    }
                }
            }
        }
        
        // Swap arrays sem c√≥pia
        temp_u = u; u = u_old; u_old = temp_u;
        temp_v = v; v = v_old; v_old = temp_v;
        
        apply_boundary_conditions_parallel();
    }
    
    double end = omp_get_wtime();
    double tempo = end - start;
    
    printf("   ‚è±Ô∏è  Tempo paralelo tiled: %.4f segundos\n", tempo);
    printf("   üîÑ %.1f itera√ß√µes/segundo\n", ITER / tempo);
    
    return tempo;
}

// VERS√ÉO 3: Simula√ß√£o paralela com loop fusion m√°ximo
double simulate_parallel_fused(int num_threads) {
    printf("üöÄ Executando vers√£o PARALELA FUSED (%d threads)...\n", num_threads);
    
    omp_set_num_threads(num_threads);
    double start = omp_get_wtime();
    
    for (int iter = 0; iter < ITER; iter++) {
        // Loop fusion: c√°lculo e update em um √∫nico passo
        #pragma omp parallel for num_threads(num_threads) schedule(static)
        for (int i = 1; i < N-1; i++) {
            // Prefetch pr√≥ximas 2 linhas
            if (i < N-3) {
                __builtin_prefetch(&U((i+2), 1), 0, 1);
                __builtin_prefetch(&V((i+2), 1), 0, 1);
            }
            
            for (int j = 1; j < N-1; j++) {
                // C√°lculo in-place do Laplaciano
                int idx = i*N + j;
                double lap_u = u[idx + N] + u[idx - N] + u[idx + 1] + u[idx - 1] - 4.0 * u[idx];
                double lap_v = v[idx + N] + v[idx - N] + v[idx + 1] + v[idx - 1] - 4.0 * v[idx];
                
                // Update in-place (usando arrays auxiliares)
                u_old[idx] = u[idx] + DT * NU * lap_u;
                v_old[idx] = v[idx] + DT * NU * lap_v;
            }
        }
        
        // Swap ponteiros (O(1) operation)
        temp_u = u; u = u_old; u_old = temp_u;
        temp_v = v; v = v_old; v_old = temp_v;
        
        apply_boundary_conditions_parallel();
    }
    
    double end = omp_get_wtime();
    double tempo = end - start;
    
    printf("   ‚è±Ô∏è  Tempo paralelo fused: %.4f segundos\n", tempo);
    printf("   üîÑ %.1f itera√ß√µes/segundo\n", ITER / tempo);
    
    return tempo;
}

// VERS√ÉO 4: Simula√ß√£o ultra-otimizada com todas as otimiza√ß√µes
double simulate_ultra_optimized(int num_threads) {
    printf("üöÄ Executando vers√£o ULTRA-OTIMIZADA (%d threads)...\n", num_threads);
    
    omp_set_num_threads(num_threads);
    double start = omp_get_wtime();
    
    // Pr√©-calcular constantes
    const double dt_nu = DT * NU;
    const double four_dt_nu = 4.0 * dt_nu;
    
    for (int iter = 0; iter < ITER; iter++) {
        #pragma omp parallel num_threads(num_threads)
        {
            // Thread-local prefetching and vectorization
            #pragma omp for schedule(static) nowait
            for (int i = 1; i < N-1; i++) {
                // Prefetch com m√∫ltiplas linhas de anteced√™ncia
                if (i < N-3) {
                    __builtin_prefetch(&U((i+3), 0), 0, 3);
                    __builtin_prefetch(&V((i+3), 0), 0, 3);
                }
                
                // Vectoriza√ß√£o manual com loop unrolling
                int j;
                for (j = 1; j < N-5; j += 4) {
                    // Process 4 elements at once (manual vectorization)
                    for (int k = 0; k < 4; k++) {
                        int idx = i*N + (j+k);
                        double curr_u = u[idx];
                        double curr_v = v[idx];
                        
                        // Otimiza√ß√£o: evitar recarregar √≠ndices
                        double lap_u = u[idx + N] + u[idx - N] + u[idx + 1] + u[idx - 1] - four_dt_nu * curr_u;
                        double lap_v = v[idx + N] + v[idx - N] + v[idx + 1] + v[idx - 1] - four_dt_nu * curr_v;
                        
                        u_old[idx] = curr_u + dt_nu * lap_u;
                        v_old[idx] = curr_v + dt_nu * lap_v;
                    }
                }
                
                // Handle remaining elements
                for (; j < N-1; j++) {
                    int idx = i*N + j;
                    double curr_u = u[idx];
                    double curr_v = v[idx];
                    
                    double lap_u = u[idx + N] + u[idx - N] + u[idx + 1] + u[idx - 1] - 4.0 * curr_u;
                    double lap_v = v[idx + N] + v[idx - N] + v[idx + 1] + v[idx - 1] - 4.0 * curr_v;
                    
                    u_old[idx] = curr_u + dt_nu * lap_u;
                    v_old[idx] = curr_v + dt_nu * lap_v;
                }
            }
            
            // Barrier impl√≠cita antes do swap
        }
        
        // Atomic pointer swap
        temp_u = u; u = u_old; u_old = temp_u;
        temp_v = v; v = v_old; v_old = temp_v;
        
        apply_boundary_conditions_parallel();
    }
    
    double end = omp_get_wtime();
    double tempo = end - start;
    
    printf("   ‚è±Ô∏è  Tempo ultra-otimizado: %.4f segundos\n", tempo);
    printf("   üîÑ %.1f itera√ß√µes/segundo\n", ITER / tempo);
    
    return tempo;
}

int main(int argc, char *argv[]) {
    // Processar argumentos
    if (argc >= 2) N = atoi(argv[1]);
    if (argc >= 3) ITER = atoi(argv[2]);
    if (argc >= 4) NUM_THREADS = atoi(argv[3]);
    
    printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë           üöÄ SIMULA√á√ÉO NAVIER-STOKES OTIMIZADA üöÄ               ‚ïë\n");
    printf("‚ïë                        TAREFA 12                                ‚ïë\n");
    printf("‚ïë                  Vers√£o Ultra-Performante                       ‚ïë\n");
    printf("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n");
    printf("‚ïë üìè Grid: %dx%d pontos                                          ‚ïë\n", N, N);
    printf("‚ïë üîÑ Itera√ß√µes: %d                                               ‚ïë\n", ITER);
    printf("‚ïë ‚ö° Threads: %d                                                  ‚ïë\n", NUM_THREADS);
    printf("‚ïë üß† Cache Tile Size: %d                                         ‚ïë\n", TILE_SIZE);
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n");
    
    printf("üîß OTIMIZA√á√ïES IMPLEMENTADAS:\n");
    printf("   ‚úÖ Cache Blocking/Tiling\n");
    printf("   ‚úÖ Memory Layout Cont√≠guo\n");
    printf("   ‚úÖ Loop Fusion\n");
    printf("   ‚úÖ First Touch Initialization\n");
    printf("   ‚úÖ Prefetch Hints\n");
    printf("   ‚úÖ Vectoriza√ß√£o Manual\n");
    printf("   ‚úÖ Schedule Otimizado\n");
    printf("   ‚úÖ Boundary Update Paralelo\n");
    printf("   ‚úÖ In-place Updates\n");
    printf("   ‚úÖ Pointer Swapping\n\n");
    
    // Inicializa√ß√£o otimizada
    initialize_arrays_parallel();
    create_perturbation_optimized();
    apply_boundary_conditions_parallel();
    
    // Array para resultados
    double tempos[4];
    int cores[] = {1, NUM_THREADS/2, NUM_THREADS, NUM_THREADS};
    const char* nomes[] = {"Serial Otimizado", "Paralelo Tiled", "Paralelo Fused", "Ultra-Otimizado"};
    
    // TESTE 1: Serial otimizado
    printf("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
    tempos[0] = simulate_serial_optimized();
    
    // Resetar estado
    create_perturbation_optimized();
    apply_boundary_conditions_parallel();
    
    // TESTE 2: Paralelo com cache tiling
    printf("\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
    tempos[1] = simulate_parallel_tiled(NUM_THREADS/2);
    
    // Resetar estado  
    create_perturbation_optimized();
    apply_boundary_conditions_parallel();
    
    // TESTE 3: Paralelo com loop fusion
    printf("\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
    tempos[2] = simulate_parallel_fused(NUM_THREADS);
    
    // Resetar estado
    create_perturbation_optimized();
    apply_boundary_conditions_parallel();
    
    // TESTE 4: Ultra-otimizado
    printf("\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
    tempos[3] = simulate_ultra_optimized(NUM_THREADS);
    
    // AN√ÅLISE DE RESULTADOS
    printf("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë                    üìä AN√ÅLISE DE PERFORMANCE                     ‚ïë\n");
    printf("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n");
    for (int i = 0; i < 4; i++) {
        double speedup = (i == 0) ? 1.0 : tempos[0] / tempos[i];
        printf("‚ïë %-20s: %8.4fs (speedup: %5.2fx)              ‚ïë\n", 
               nomes[i], tempos[i], speedup);
    }
    printf("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n");
    printf("‚ïë üèÜ Melhor otimiza√ß√£o: %.2fx speedup                             ‚ïë\n", 
           tempos[0] / tempos[3]);
    printf("‚ïë üéØ Efici√™ncia: %.1f%% com %d threads                           ‚ïë\n", 
           (tempos[0] / tempos[3]) / NUM_THREADS * 100, NUM_THREADS);
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
    
    // Cleanup
    free(u); free(v); free(u_old); free(v_old);
    
    printf("\n‚ú® Simula√ß√£o ultra-otimizada conclu√≠da! ‚ú®\n");
    
    return 0;
}
