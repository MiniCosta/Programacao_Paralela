<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tarefa 10: Compara√ß√£o de Mecanismos de Sincroniza√ß√£o em OpenMP</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            color: #333;
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #2980b9;
            border-bottom: 2px solid #3498db;
            padding-bottom: 5px;
            margin-top: 30px;
        }
        h3 {
            color: #34495e;
            margin-top: 25px;
        }
        h4 {
            color: #7f8c8d;
            margin-top: 20px;
        }
        code {
            background-color: #f8f9fa;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #e74c3c;
        }
        pre {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 15px;
            overflow-x: auto;
            margin: 10px 0;
        }
        pre code {
            background: none;
            padding: 0;
            color: #2c3e50;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #3498db;
            color: white;
            font-weight: bold;
        }
        tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        tr:hover {
            background-color: #e8f4f8;
        }
        .highlight {
            background-color: #fff3cd;
            padding: 15px;
            border-left: 4px solid #ffc107;
            margin: 15px 0;
        }
        .success {
            background-color: #d4edda;
            padding: 15px;
            border-left: 4px solid #28a745;
            margin: 15px 0;
        }
        .warning {
            background-color: #f8d7da;
            padding: 15px;
            border-left: 4px solid #dc3545;
            margin: 15px 0;
        }
        .star {
            color: #ffc107;
        }
        .performance-best {
            font-weight: bold;
            color: #28a745;
        }
        ul {
            margin: 10px 0;
            padding-left: 30px;
        }
        li {
            margin: 5px 0;
        }
        .toc {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 20px;
            margin: 20px 0;
        }
        .toc h3 {
            margin-top: 0;
            color: #495057;
        }
        .toc ul {
            list-style-type: none;
            padding-left: 0;
        }
        .toc li {
            margin: 8px 0;
        }
        .toc a {
            text-decoration: none;
            color: #007bff;
        }
        .toc a:hover {
            text-decoration: underline;
        }
        .emoji {
            font-size: 1.2em;
        }
        img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body>

<h1>Tarefa 10: Compara√ß√£o de Mecanismos de Sincroniza√ß√£o em OpenMP</h1>

<div class="toc">
    <h3>√çndice</h3>
    <ul>
        <li><a href="#descricao">Descri√ß√£o</a></li>
        <li><a href="#fundamentos">Fundamentos Te√≥ricos das Cl√°usulas OpenMP</a></li>
        <li><a href="#implementacoes">Implementa√ß√µes</a></li>
        <li><a href="#resultados">Resultados Experimentais</a></li>
        <li><a href="#teoria">Teoria dos Mecanismos de Sincroniza√ß√£o</a></li>
        <li><a href="#roteiro">Roteiro para Escolha do Mecanismo</a></li>
        <li><a href="#reflexao">Reflex√£o sobre Desempenho e Produtividade</a></li>
        <li><a href="#conclusao">Conclus√£o</a></li>
    </ul>
</div>

<h2 id="descricao">Descri√ß√£o</h2>

<p>Este projeto implementa e compara cinco diferentes abordagens para paraleliza√ß√£o do algoritmo de Monte Carlo para estimativa de œÄ, explorando diversos mecanismos de sincroniza√ß√£o em OpenMP. O objetivo √© analisar o desempenho, produtividade e aplicabilidade de cada t√©cnica.</p>

<h2 id="fundamentos">Fundamentos Te√≥ricos das Cl√°usulas OpenMP</h2>

<h3>1. <code>#pragma omp critical</code></h3>

<p><strong>Defini√ß√£o</strong>: Uma regi√£o cr√≠tica √© uma se√ß√£o de c√≥digo que deve ser executada por apenas uma thread por vez, garantindo exclus√£o m√∫tua.</p>

<p><strong>Teoria</strong>:</p>
<ul>
    <li><strong>Exclus√£o M√∫tua</strong>: Implementa o conceito fundamental de se√ß√£o cr√≠tica da programa√ß√£o concorrente</li>
    <li><strong>Implementa√ß√£o</strong>: Utiliza mutex interno do OpenMP (similar a <code>pthread_mutex_t</code>)</li>
    <li><strong>Atomicidade</strong>: Garante que toda a se√ß√£o de c√≥digo seja executada atomicamente</li>
    <li><strong>Serializa√ß√£o</strong>: For√ßa execu√ß√£o sequencial dentro da regi√£o cr√≠tica</li>
</ul>

<p><strong>Caracter√≠sticas T√©cnicas</strong>:</p>
<pre><code>// Implementa√ß√£o conceitual interna
static omp_lock_t __critical_default_lock__;

// Ao encontrar #pragma omp critical
omp_set_lock(&__critical_default_lock__);
// c√≥digo da regi√£o cr√≠tica
omp_unset_lock(&__critical_default_lock__);</code></pre>

<p><strong>Overhead</strong>:</p>
<ul>
    <li><strong>Aquisi√ß√£o/libera√ß√£o do lock</strong>: ~50-200 ciclos de CPU</li>
    <li><strong>Conten√ß√£o</strong>: Aumenta linearmente com n√∫mero de threads</li>
    <li><strong>Context switching</strong>: Poss√≠vel troca de contexto se lock n√£o dispon√≠vel</li>
</ul>

<h3>2. <code>#pragma omp atomic</code></h3>

<p><strong>Defini√ß√£o</strong>: Garante que uma opera√ß√£o espec√≠fica seja executada atomicamente, sem interrup√ß√£o por outras threads.</p>

<p><strong>Teoria</strong>:</p>
<ul>
    <li><strong>Atomicidade em Hardware</strong>: Utiliza instru√ß√µes at√¥micas da CPU (LOCK prefix no x86)</li>
    <li><strong>Memory Ordering</strong>: Controla ordem de opera√ß√µes na mem√≥ria</li>
    <li><strong>Granularidade Fina</strong>: Prote√ß√£o apenas da opera√ß√£o espec√≠fica, n√£o de blocos de c√≥digo</li>
    <li><strong>Consist√™ncia de Cache</strong>: Garante visibilidade imediata entre threads</li>
</ul>

<p><strong>Tipos de Opera√ß√µes Suportadas</strong>:</p>
<pre><code>// B√°sicas (OpenMP 2.0+)
#pragma omp atomic
x++;                    // Incremento

#pragma omp atomic
x += expr;              // Update

// Estendidas (OpenMP 3.1+)
#pragma omp atomic read
v = x;                  // Read

#pragma omp atomic write
x = expr;               // Write

#pragma omp atomic capture
{v = x; x++;}          // Capture</code></pre>

<h3>3. Contadores Privados (Thread-Local Storage)</h3>

<p><strong>Defini√ß√£o</strong>: Cada thread mant√©m sua pr√≥pria c√≥pia de vari√°veis, eliminando conten√ß√£o durante a computa√ß√£o.</p>

<p><strong>Vantagens Te√≥ricas</strong>:</p>
<ul>
    <li><strong>Cache Locality</strong>: Dados sempre na cache L1 da thread</li>
    <li><strong>Zero False Sharing</strong>: Sem interfer√™ncia entre threads</li>
    <li><strong>Escalabilidade Linear</strong>: Performance cresce com threads</li>
    <li><strong>Predizibilidade</strong>: Comportamento determin√≠stico</li>
</ul>

<h3>4. Vetor de Contadores Privados</h3>

<p><strong>Defini√ß√£o</strong>: Extens√£o dos contadores privados usando array para armazenar resultados individuais de cada thread.</p>

<p><strong>Vantagens</strong>:</p>
<ul>
    <li><strong>M√°ximo Paralelismo</strong>: Zero conten√ß√£o</li>
    <li><strong>Debugging</strong>: F√°cil inspecionar resultados por thread</li>
    <li><strong>Flexibilidade</strong>: Suporte a opera√ß√µes complexas</li>
    <li><strong>Otimiza√ß√£o Manual</strong>: Controle sobre layout de mem√≥ria</li>
</ul>

<h3>5. <code>#pragma omp reduction</code></h3>

<p><strong>Defini√ß√£o</strong>: Cl√°usula que automatiza o padr√£o de redu√ß√£o, otimizando a agrega√ß√£o de valores de m√∫ltiplas threads.</p>

<p><strong>Operadores Suportados</strong>:</p>
<ul>
    <li><strong>Aritm√©ticos</strong>: <code>+</code>, <code>-</code>, <code>*</code></li>
    <li><strong>Compara√ß√£o</strong>: <code>max</code>, <code>min</code></li>
    <li><strong>L√≥gicos</strong>: <code>&&</code>, <code>||</code></li>
    <li><strong>Bitwise</strong>: <code>&</code>, <code>|</code>, <code>^</code></li>
</ul>

<h2 id="implementacoes">Implementa√ß√µes</h2>

<h3>1. Contador Compartilhado com <code>#pragma omp critical</code></h3>
<pre><code>#pragma omp critical
acertos_critical++;</code></pre>
<ul>
    <li><strong>Sincroniza√ß√£o</strong>: Regi√£o cr√≠tica bloqueia acesso concorrente</li>
    <li><strong>Overhead</strong>: Alto - serializa√ß√£o total de incrementos</li>
    <li><strong>Uso</strong>: Prote√ß√£o de c√≥digo complexo que n√£o pode ser atomizado</li>
</ul>

<h3>2. Contador Compartilhado com <code>#pragma omp atomic</code></h3>
<pre><code>#pragma omp atomic
acertos_atomic++;</code></pre>
<ul>
    <li><strong>Sincroniza√ß√£o</strong>: Opera√ß√£o at√¥mica em hardware</li>
    <li><strong>Overhead</strong>: M√©dio - contenda por vari√°vel compartilhada</li>
    <li><strong>Uso</strong>: Opera√ß√µes simples (incremento, soma, etc.)</li>
</ul>

<h3>3. Contadores Privados (Redu√ß√£o Manual com Atomic)</h3>
<pre><code>long long int local = 0;
// ... loop com contador local
#pragma omp atomic
acertos_privado += local;</code></pre>
<ul>
    <li><strong>Sincroniza√ß√£o</strong>: M√≠nima - apenas na redu√ß√£o final</li>
    <li><strong>Overhead</strong>: Baixo - uma sincroniza√ß√£o por thread</li>
    <li><strong>Uso</strong>: Quando reduction n√£o est√° dispon√≠vel</li>
</ul>

<h3>4. Vetor de Contadores Privados</h3>
<pre><code>acertos_vet[tid] = local;
// ... redu√ß√£o sequencial posterior</code></pre>
<ul>
    <li><strong>Sincroniza√ß√£o</strong>: Nenhuma durante c√°lculo</li>
    <li><strong>Overhead</strong>: M√≠nimo - sem conten√ß√£o</li>
    <li><strong>Uso</strong>: Controle total sobre redu√ß√£o e debugging</li>
</ul>

<h3>5. Cl√°usula <code>reduction</code></h3>
<pre><code>#pragma omp parallel for reduction(+:acertos_reduction)</code></pre>
<ul>
    <li><strong>Sincroniza√ß√£o</strong>: Autom√°tica pelo compilador</li>
    <li><strong>Overhead</strong>: Otimizado - implementa√ß√£o eficiente</li>
    <li><strong>Uso</strong>: Padr√µes de redu√ß√£o conhecidos</li>
</ul>

<h2 id="resultados">Resultados Experimentais</h2>

<h3>Teste com 100M pontos (4 threads, gcc sem otimiza√ß√£o)</h3>

<table>
    <tr>
        <th>Vers√£o</th>
        <th>Mecanismo</th>
        <th>œÄ Estimado</th>
        <th>Tempo (s)</th>
        <th>Speedup</th>
        <th>Efici√™ncia</th>
    </tr>
    <tr>
        <td>1</td>
        <td>Critical</td>
        <td>3.1416106800</td>
        <td>8.294</td>
        <td>1.0x</td>
        <td>25%</td>
    </tr>
    <tr>
        <td>2</td>
        <td>Atomic</td>
        <td>3.1414664000</td>
        <td>2.246</td>
        <td>3.7x</td>
        <td>92%</td>
    </tr>
    <tr style="background-color: #d4edda;">
        <td>3</td>
        <td>Privado</td>
        <td>3.1414664000</td>
        <td>0.358</td>
        <td class="performance-best">23.2x</td>
        <td class="performance-best">580%</td>
    </tr>
    <tr style="background-color: #d4edda;">
        <td>4</td>
        <td>Vetor</td>
        <td>3.1414664000</td>
        <td>0.355</td>
        <td class="performance-best">23.4x</td>
        <td class="performance-best">585%</td>
    </tr>
    <tr style="background-color: #d1ecf1;">
        <td>5</td>
        <td>Reduction</td>
        <td>3.1414664000</td>
        <td>0.348</td>
        <td class="performance-best">23.8x</td>
        <td class="performance-best">595%</td>
    </tr>
</table>

<h3>Teste com 500M pontos (4 threads, gcc sem otimiza√ß√£o)</h3>

<table>
    <tr>
        <th>Vers√£o</th>
        <th>Mecanismo</th>
        <th>œÄ Estimado</th>
        <th>Tempo (s)</th>
        <th>Speedup</th>
        <th>Efici√™ncia</th>
    </tr>
    <tr>
        <td>1</td>
        <td>Critical</td>
        <td>3.1415775360</td>
        <td>42.30159</td>
        <td>1.0x</td>
        <td>25%</td>
    </tr>
    <tr>
        <td>2</td>
        <td>Atomic</td>
        <td>3.1415495200</td>
        <td>8.35678</td>
        <td>5.06x</td>
        <td class="performance-best">127%</td>
    </tr>
    <tr style="background-color: #d4edda;">
        <td>3</td>
        <td>Privado</td>
        <td>3.1415645520</td>
        <td>2.00836</td>
        <td>21.06x</td>
        <td class="performance-best">526%</td>
    </tr>
    <tr style="background-color: #d4edda;">
        <td>4</td>
        <td>Vetor</td>
        <td>3.1415645520</td>
        <td>1.77873</td>
        <td class="performance-best">23.77x</td>
        <td class="performance-best">594%</td>
    </tr>
    <tr style="background-color: #d1ecf1;">
        <td>5</td>
        <td>Reduction</td>
        <td>3.1416206960</td>
        <td>1.71463</td>
        <td class="performance-best">24.67x</td>
        <td class="performance-best">617%</td>
    </tr>
</table>

<h3>An√°lise dos Resultados</h3>

<h4>Desempenho por Escala</h4>

<p><strong>100M pontos:</strong></p>
<ul>
    <li><strong>Critical</strong>: Baseline com alto overhead de sincroniza√ß√£o</li>
    <li><strong>Atomic</strong>: 3.7x melhoria - redu√ß√£o significativa da conten√ß√£o</li>
    <li><strong>Privados/Reduction</strong>: 23-24x melhoria - paraleliza√ß√£o quase ideal</li>
</ul>

<p><strong>500M pontos:</strong></p>
<ul>
    <li><strong>Critical</strong>: Mant√©m baixa performance (42.3s)</li>
    <li><strong>Atomic</strong>: 5.06x melhoria - cresce com escala</li>
    <li><strong>Privados</strong>: 21-24x melhoria - <strong>Reduction √© o melhor</strong> (24.67x)</li>
</ul>

<h4>Escalabilidade</h4>
<ul>
    <li><strong>Critical</strong>: N√£o escala - overhead constante alto</li>
    <li><strong>Atomic</strong>: Escala moderadamente (3.7x ‚Üí 5.06x)</li>
    <li><strong>Privados/Reduction</strong>: Excelente escalabilidade mantida (21-24.67x)</li>
</ul>

<h2 id="roteiro">Roteiro para Escolha do Mecanismo de Sincroniza√ß√£o</h2>

<div class="success">
    <h3><span class="emoji">üéØ</span> Guia de Decis√£o R√°pida</h3>

    <h4>1. Use <code>reduction</code> quando:</h4>
    <ul>
        <li>‚úÖ Opera√ß√£o √© uma redu√ß√£o padr√£o (+, *, max, min, etc.)</li>
        <li>‚úÖ Quer c√≥digo limpo e leg√≠vel</li>
        <li>‚úÖ Performance √© importante</li>
        <li>‚úÖ OpenMP 2.0+ dispon√≠vel</li>
    </ul>

    <h4>2. Use contadores privados quando:</h4>
    <ul>
        <li>‚úÖ <code>reduction</code> n√£o suporta sua opera√ß√£o</li>
        <li>‚úÖ Precisa de controle total sobre redu√ß√£o</li>
        <li>‚úÖ Debugging/profiling detalhado necess√°rio</li>
        <li>‚úÖ Opera√ß√£o complexa n√£o-padr√£o</li>
    </ul>

    <h4>3. Use <code>#pragma omp atomic</code> quando:</h4>
    <ul>
        <li>‚úÖ Opera√ß√£o simples (++, +=, -=, *=, etc.)</li>
        <li>‚úÖ <code>reduction</code> n√£o dispon√≠vel/aplic√°vel</li>
        <li>‚úÖ Necess√°rio acesso concorrente frequente</li>
        <li>‚úÖ Performance moderada aceit√°vel</li>
    </ul>

    <h4>4. Use <code>#pragma omp critical</code> quando:</h4>
    <ul>
        <li>‚úÖ C√≥digo complexo multi-instru√ß√£o</li>
        <li>‚úÖ Opera√ß√µes n√£o-at√¥micas</li>
        <li>‚úÖ I/O ou chamadas de sistema</li>
        <li>‚úÖ Performance n√£o √© prioridade</li>
    </ul>
</div>

<h3><span class="emoji">üìä</span> Matriz de Decis√£o por Crit√©rio</h3>

<table>
    <tr>
        <th>Crit√©rio</th>
        <th>Reduction</th>
        <th>Privados</th>
        <th>Atomic</th>
        <th>Critical</th>
        <th>Critical Named</th>
        <th>Locks</th>
    </tr>
    <tr>
        <td><strong>Performance</strong></td>
        <td><span class="star">‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</span></td>
        <td><span class="star">‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</span></td>
        <td><span class="star">‚≠ê‚≠ê‚≠ê</span></td>
        <td><span class="star">‚≠ê</span></td>
        <td><span class="star">‚≠ê‚≠ê</span></td>
        <td><span class="star">‚≠ê‚≠ê‚≠ê‚≠ê</span></td>
    </tr>
    <tr>
        <td><strong>Simplicidade</strong></td>
        <td><span class="star">‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</span></td>
        <td><span class="star">‚≠ê‚≠ê‚≠ê</span></td>
        <td><span class="star">‚≠ê‚≠ê‚≠ê‚≠ê</span></td>
        <td><span class="star">‚≠ê‚≠ê‚≠ê‚≠ê</span></td>
        <td><span class="star">‚≠ê‚≠ê‚≠ê</span></td>
        <td><span class="star">‚≠ê‚≠ê</span></td>
    </tr>
    <tr>
        <td><strong>Flexibilidade</strong></td>
        <td><span class="star">‚≠ê‚≠ê</span></td>
        <td><span class="star">‚≠ê‚≠ê‚≠ê‚≠ê</span></td>
        <td><span class="star">‚≠ê‚≠ê</span></td>
        <td><span class="star">‚≠ê‚≠ê‚≠ê‚≠ê</span></td>
        <td><span class="star">‚≠ê‚≠ê‚≠ê‚≠ê</span></td>
        <td><span class="star">‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</span></td>
    </tr>
    <tr>
        <td><strong>Escalabilidade</strong></td>
        <td><span class="star">‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</span></td>
        <td><span class="star">‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</span></td>
        <td><span class="star">‚≠ê‚≠ê‚≠ê</span></td>
        <td><span class="star">‚≠ê</span></td>
        <td><span class="star">‚≠ê‚≠ê‚≠ê</span></td>
        <td><span class="star">‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</span></td>
    </tr>
</table>

<h2 id="reflexao">Reflex√£o sobre Desempenho e Produtividade</h2>

<div class="highlight">
    <h3><span class="emoji">üèÜ</span> A Escolha √ìbvia: <code>reduction</code> em 90% dos Casos</h3>

    <p><strong>Em termos simples</strong>: Se voc√™ est√° fazendo uma opera√ß√£o de redu√ß√£o (somar, contar, encontrar m√°ximo/m√≠nimo), <strong>sempre use <code>reduction</code> primeiro</strong>. Ela √© simultaneamente:</p>
    <ul>
        <li><strong>Mais r√°pida</strong> (24.67x speedup vs 1x do critical)</li>
        <li><strong>Mais simples</strong> (uma linha de c√≥digo)</li>
        <li><strong>Menos propensa a bugs</strong> (o compilador faz tudo)</li>
    </ul>

    <h4>Por que <code>reduction</code> √© superior?</h4>
    <ol>
        <li><strong>Performance excepcional</strong>: O compilador gera c√≥digo altamente otimizado</li>
        <li><strong>C√≥digo limpo</strong>: Uma linha resolve tudo - <code>reduction(+:contador)</code></li>
        <li><strong>Zero bugs de sincroniza√ß√£o</strong>: Voc√™ n√£o precisa gerenciar locks</li>
        <li><strong>Funciona em qualquer arquitetura</strong>: Intel, AMD, ARM - otimizado automaticamente</li>
    </ol>

    <h4>Quando N√ÉO usar <code>reduction</code>?</h4>
    <p><strong>Apenas 3 situa√ß√µes espec√≠ficas:</strong></p>
    <ol>
        <li><strong>OpenMP muito antigo</strong> (anterior a 2.0 - raro hoje)</li>
        <li><strong>Opera√ß√£o complexa n√£o-padr√£o</strong></li>
        <li><strong>Debugging detalhado</strong>: Quando voc√™ precisa ver o que cada thread fez individualmente</li>
    </ol>
</div>

<div class="success">
    <h3><span class="emoji">üí°</span> Regra Pr√°tica Simples</h3>

    <p><strong>Para 90% dos casos de sincroniza√ß√£o em OpenMP:</strong></p>
    <pre><code>// ‚úÖ SEMPRE tente isso primeiro
#pragma omp parallel for reduction(+:contador)
for (int i = 0; i < N; i++) {
    if (condicao(i)) contador++;
}</code></pre>

    <p><strong>S√≥ v√° para outras op√ß√µes se reduction n√£o funcionar para seu caso espec√≠fico.</strong></p>

    <p><strong>Lembre-se</strong>: <code>reduction</code> n√£o √© apenas mais r√°pida, √© tamb√©m <strong>mais simples de escrever e depurar</strong>. √â literalmente a melhor escolha em todos os aspectos para padr√µes de redu√ß√£o.</p>
</div>

<h3>Insights dos Resultados Experimentais</h3>

<h4>Desempenho por Mecanismo</h4>
<ul>
    <li><strong>Critical</strong>: Gargalo severo e constante - <strong>42x mais lento</strong> que reduction</li>
    <li><strong>Atomic</strong>: Melhoria substancial - <strong>5x melhor</strong> que critical em larga escala</li>
    <li><strong>Privados</strong>: Excelente performance - <strong>21-24x melhoria</strong></li>
    <li><strong>Reduction</strong>: <strong>Melhor absoluto</strong> - 24.67x speedup com c√≥digo mais limpo</li>
</ul>

<h4>Escalabilidade Observada</h4>
<ul>
    <li><strong>Critical</strong>: Performance <strong>n√£o melhora</strong> com escala - overhead fixo alto</li>
    <li><strong>Atomic</strong>: <strong>Melhora gradual</strong> (3.7x ‚Üí 5.06x) - escala moderadamente</li>
    <li><strong>Privados/Reduction</strong>: <strong>Escalabilidade mantida</strong> - performance consistente</li>
</ul>

<h2 id="conclusao">Conclus√£o</h2>

<p>A escolha do mecanismo de sincroniza√ß√£o deve equilibrar:</p>
<ul>
    <li><strong>Performance</strong>: Reduction/Privados > Atomic > Critical</li>
    <li><strong>Simplicidade</strong>: Reduction > Atomic > Critical > Privados</li>
    <li><strong>Flexibilidade</strong>: Locks > Critical > Privados > Atomic > Reduction</li>
</ul>

<div class="success">
    <p><strong>Recomenda√ß√£o Final</strong>: Para aplica√ß√µes cient√≠ficas, privilegie <code>reduction</code> quando poss√≠vel, contadores privados para casos complexos, e reserve <code>critical</code> apenas para c√≥digo n√£o-paraleliz√°vel.</p>
</div>

<h2>Compila√ß√£o e Execu√ß√£o</h2>

<pre><code>gcc -fopenmp -o tarefa10 tarefa10.c
./tarefa10 [num_pontos] [num_threads]

# Exemplo
./tarefa10 100000000 4</code></pre>

<h2>Resultados Visuais</h2>

<img src="tarefa10.png" alt="Gr√°fico de Performance - Compara√ß√£o dos Mecanismos de Sincroniza√ß√£o" title="Compara√ß√£o de Performance entre os diferentes mecanismos de sincroniza√ß√£o em OpenMP">

<p style="text-align: center; color: #666; font-style: italic;">
C√≥digo Tarefa 10</p>

</body>
</html>
