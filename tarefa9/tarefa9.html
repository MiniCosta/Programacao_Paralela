<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tarefa 9: Regi√µes Cr√≠ticas Nomeadas vs Locks Expl√≠citos</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #34495e;
            border-left: 4px solid #3498db;
            padding-left: 15px;
            margin-top: 30px;
        }
        h3 {
            color: #2980b9;
            margin-top: 25px;
        }
        .code-block {
            background-color: #2d3748;
            color: #e2e8f0;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 15px 0;
            border-left: 4px solid #4299e1;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            line-height: 1.4;
        }
        .code-block code {
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
        .highlight {
            background-color: #fff3cd;
            padding: 15px;
            border-left: 4px solid #ffc107;
            margin: 15px 0;
        }
        .success {
            background-color: #d4edda;
            padding: 15px;
            border-left: 4px solid #28a745;
            margin: 15px 0;
        }
        .warning {
            background-color: #f8d7da;
            padding: 15px;
            border-left: 4px solid #dc3545;
            margin: 15px 0;
        }
        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .comparison-item {
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #e9ecef;
        }
        .comparison-item.critical {
            background-color: #e8f4f8;
            border-color: #3498db;
        }
        .comparison-item.locks {
            background-color: #f0f8e8;
            border-color: #27ae60;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #3498db;
            color: white;
        }
        tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        .performance-improvement {
            background-color: #d4edda !important;
            color: #155724 !important;
            font-weight: bold;
            text-align: center;
            padding: 15px !important;
        }
        .output-sample {
            background-color: #1e1e1e;
            color: #d4d4d4;
            padding: 25px;
            border-radius: 10px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            overflow-x: auto;
            margin: 20px 0;
            border: 2px solid #3c3c3c;
            line-height: 1.6;
            font-size: 14px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .output-sample .header {
            color: #ffd700;
            font-weight: bold;
            display: block;
            text-align: center;
        }
        .output-sample .section {
            color: #4ec9b0;
            font-weight: bold;
            display: block;
            margin: 15px 0 5px 0;
            border-bottom: 1px solid #4ec9b0;
            padding-bottom: 2px;
        }
        .output-sample .result {
            color: #9cdcfe;
            font-weight: bold;
            display: block;
            margin: 10px 0 5px 0;
        }
        .output-sample .time {
            color: #f14c4c;
            font-weight: bold;
        }
        .output-sample .input {
            color: #ce9178;
            font-style: italic;
        }
        .output-sample .success {
            color: #b5cea8;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Tarefa 9: Regi√µes Cr√≠ticas Nomeadas vs Locks Expl√≠citos</h1>
        
        <h2>üìù Objetivo da Tarefa</h2>
        <p>Desenvolver um programa OpenMP que demonstra a diferen√ßa entre <strong>regi√µes cr√≠ticas nomeadas</strong> e <strong>locks expl√≠citos</strong> para sincroniza√ß√£o de estruturas de dados paralelas, especificamente listas encadeadas.</p>
        
        <div class="highlight">
            <strong>Requisitos principais:</strong>
            <ul>
                <li>Usar OpenMP Tasks para realizar N inser√ß√µes</li>
                <li>Implementar duas listas encadeadas com regi√µes cr√≠ticas nomeadas</li>
                <li>Escolha aleat√≥ria da lista para inser√ß√£o</li>
                <li>Generalizar para N listas usando locks expl√≠citos</li>
                <li>Explicar por que regi√µes cr√≠ticas nomeadas t√™m limita√ß√µes</li>
            </ul>
        </div>

        <h2>üîê Tipos de Locks em OpenMP</h2>
        
        <p>OpenMP oferece diferentes mecanismos de sincroniza√ß√£o, cada um com caracter√≠sticas espec√≠ficas para diferentes cen√°rios de uso.</p>
        
        <h3>1. Regi√µes Cr√≠ticas Simples</h3>
        <p>A forma mais b√°sica de sincroniza√ß√£o, onde apenas uma thread pode executar o bloco por vez:</p>
        
        <div class="code-block"><code>#pragma omp critical
{
    // Apenas uma thread executa este bloco por vez
    shared_variable++;
}</code></div>
        
        <div class="warning">
            <strong>‚ö†Ô∏è Limita√ß√£o:</strong> Todas as regi√µes cr√≠ticas simples compartilham o mesmo lock global, criando gargalos desnecess√°rios.
        </div>
        
        <h3>2. Regi√µes Cr√≠ticas Nomeadas</h3>
        <p>Permitem m√∫ltiplas se√ß√µes cr√≠ticas independentes com nomes √∫nicos:</p>
        
        <div class="code-block"><code>#pragma omp critical(nome_do_lock)
{
    // Protegido pelo lock "nome_do_lock"
    lista1_operations();
}

#pragma omp critical(outro_nome)
{
    // Protegido pelo lock "outro_nome" - independente do anterior
    lista2_operations();
}</code></div>
        
        <div class="success">
            <strong>‚úÖ Vantagem:</strong> Diferentes nomes permitem paralelismo entre se√ß√µes cr√≠ticas distintas.
        </div>
        
        <h3>3. Locks Expl√≠citos (omp_lock_t)</h3>
        <p>Oferecem controle total sobre a sincroniza√ß√£o com gerenciamento manual:</p>
        
        <div class="code-block"><code>// Declara√ß√£o e inicializa√ß√£o
omp_lock_t my_lock;
omp_init_lock(&my_lock);

// Uso do lock
omp_set_lock(&my_lock);     // Bloqueia at√© adquirir
{
    // Se√ß√£o cr√≠tica
    critical_operations();
}
omp_unset_lock(&my_lock);   // Libera o lock

// Limpeza
omp_destroy_lock(&my_lock);</code></div>
    
        
        <h3>Compara√ß√£o Detalhada dos Tipos de Locks</h3>
        
        <table>
            <tr>
                <th>Tipo de Lock</th>
                <th>Sintaxe</th>
                <th>Flexibilidade</th>
                <th>Performance</th>
                <th>Uso Recomendado</th>
            </tr>
            <tr>
                <td><strong>Critical Simples</strong></td>
                <td><code>#pragma omp critical</code></td>
                <td>‚ùå Baixa</td>
                <td>‚ùå Baixa (lock global)</td>
                <td>Prototipagem r√°pida</td>
            </tr>
            <tr>
                <td><strong>Critical Nomeadas</strong></td>
                <td><code>#pragma omp critical(nome)</code></td>
                <td>‚ö†Ô∏è M√©dia</td>
                <td>‚úÖ Boa</td>
                <td>Pequeno n√∫mero fixo de recursos</td>
            </tr>
            <tr>
                <td><strong>Locks Expl√≠citos</strong></td>
                <td><code>omp_set_lock(&lock)</code></td>
                <td>‚úÖ Alta</td>
                <td>‚úÖ Alta</td>
                <td>Estruturas din√¢micas, arrays</td>
            </tr>
        </table>
        
        <h3>Ciclo de Vida dos Locks Expl√≠citos</h3>
        
        <div class="code-block"><code>// 1. DECLARA√á√ÉO
omp_lock_t lock;

// 2. INICIALIZA√á√ÉO (obrigat√≥ria)
omp_init_lock(&lock);

// 3. USO REPETIDO
for (int i = 0; i < n; i++) {
    omp_set_lock(&lock);        // Adquire
    {
        // Opera√ß√µes thread-safe
    }
    omp_unset_lock(&lock);      // Libera
}

// 4. DESTRUI√á√ÉO (obrigat√≥ria para evitar vazamentos)
omp_destroy_lock(&lock);</code></div>
        
        <div class="warning">
            <strong>‚ö†Ô∏è Importante:</strong> Sempre emparelhar <code>omp_init_lock()</code> com <code>omp_destroy_lock()</code> para evitar vazamentos de recursos.
        </div>

        <h3>üìñ Comandos de Lock Expl√≠cito</h3>

        <h4>üîπ <code>omp_lock_t lock;</code> - Declara√ß√£o do Lock</h4>
        <ul>
            <li><strong>Tipo opaco do OpenMP</strong> para representar um lock</li>
            <li><strong>Estado indefinido</strong> ap√≥s declara√ß√£o - n√£o pode ser usado</li>
            <li><strong>Deve ser inicializado</strong> antes do primeiro uso</li>
        </ul>

        <h4>üîπ <code>omp_init_lock(&lock);</code> - Inicializa√ß√£o do Lock</h4>
        <ul>
            <li><strong>Obrigat√≥rio</strong> antes de qualquer uso do lock</li>
            <li><strong>Aloca recursos internos</strong> do OpenMP (mutexes, sem√°foros)</li>
            <li><strong>Lock fica desbloqueado</strong> e pronto para uso</li>
            <li><strong>N√£o √© thread-safe</strong> - chame em regi√£o sequencial</li>
        </ul>

        <h4>üîπ <code>omp_set_lock(&lock);</code> - Aquisi√ß√£o do Lock</h4>
        <ul>
            <li><strong>Comportamento bloqueante</strong> - espera at√© conseguir o lock</li>
            <li><strong>Exclus√£o m√∫tua</strong> - apenas uma thread por vez</li>
            <li><strong>Thread torna-se dona</strong> do lock ap√≥s aquisi√ß√£o</li>
            <li><strong>Opera√ß√£o at√¥mica</strong> sem timeout</li>
        </ul>

        <h4>üîπ <code>omp_unset_lock(&lock);</code> - Libera√ß√£o do Lock</h4>
        <ul>
            <li><strong>Deve ser chamado pela mesma thread</strong> que fez <code>omp_set_lock()</code></li>
            <li><strong>Libera o lock</strong> para outras threads esperando</li>
            <li><strong>Thread perde ownership</strong> do lock</li>
            <li><strong>Emparelhamento obrigat√≥rio</strong> com <code>omp_set_lock()</code></li>
        </ul>

        <h4>üîπ <code>omp_destroy_lock(&lock);</code> - Destrui√ß√£o do Lock</h4>
        <ul>
            <li><strong>Libera recursos do sistema</strong> alocados na inicializa√ß√£o</li>
            <li><strong>Lock deve estar desbloqueado</strong> antes da destrui√ß√£o</li>
            <li><strong>Previne vazamentos de mem√≥ria</strong> dos recursos OpenMP</li>
            <li><strong>Emparelhar sempre</strong> com <code>omp_init_lock()</code></li>
        </ul>

        <div class="success">
            <strong>üéØ Sequ√™ncia Obrigat√≥ria:</strong>
            <p><strong>DECLARA√á√ÉO</strong> ‚Üí <strong>INICIALIZA√á√ÉO</strong> ‚Üí <strong>[AQUISI√á√ÉO ‚Üí LIBERA√á√ÉO]*</strong> ‚Üí <strong>DESTRUI√á√ÉO</strong></p>
        </div>
    

        <div class="success">
            <h4>‚úÖ Vantagens dos Locks Expl√≠citos:</h4>
            <ul>
                <li><strong>Escalabilidade Total:</strong> Funciona para qualquer n√∫mero N de listas</li>
                <li><strong>Cria√ß√£o Din√¢mica:</strong> Locks criados em runtime conforme necess√°rio</li>
                <li><strong>Flexibilidade M√°xima:</strong> Cada estrutura pode ter seu pr√≥prio lock</li>
                <li><strong>Performance Superior:</strong> Paralelismo otimizado entre todas as listas</li>
                <li><strong>Encapsulamento:</strong> Lock faz parte da estrutura de dados</li>
            </ul>
        </div>

        <h3>üéØ Por que Cada Tipo foi Escolhido</h3>

        <div class="highlight">
            <h4>üîç Decis√£o de Design do Programa:</h4>
            <p><strong>Primeira Parte - Regi√µes Cr√≠ticas Nomeadas:</strong></p>
            <ul>
                <li>Demonstrar paralelismo entre <strong>exatamente 2 listas</strong></li>
                <li>Mostrar que <code>lista1</code> e <code>lista2</code> podem operar simultaneamente</li>
                <li>Evidenciar a <strong>limita√ß√£o</strong> quando precisamos de mais listas</li>
            </ul>
            
            <p><strong>Segunda Parte - Locks Expl√≠citos:</strong></p>
            <ul>
                <li>Resolver o problema de <strong>N listas din√¢micas</strong></li>
                <li>Demonstrar <strong>escalabilidade real</strong> (testamos com 20 listas)</li>
                <li>Mostrar <strong>performance superior</strong> (74.2% mais throughput)</li>
            </ul>
        </div>

        

        <h2>üìä An√°lise Comparativa</h2>
        
        <div class="comparison">
            <div class="comparison-item critical">
                <h4>Regi√µes Cr√≠ticas Nomeadas</h4>
                <ul>
                    <li><strong>Vantagens:</strong>
                        <ul>
                            <li>Sintaxe simples</li>
                            <li>Paralelismo entre diferentes nomes</li>
                            <li>Gerenciamento autom√°tico</li>
                        </ul>
                    </li>
                    <li><strong>Limita√ß√µes:</strong>
                        <ul>
                            <li>Nomes devem ser conhecidos em tempo de compila√ß√£o</li>
                            <li>N√£o escal√°vel para N din√¢mico</li>
                            <li>Imposs√≠vel criar nomes em runtime</li>
                        </ul>
                    </li>
                </ul>
            </div>
            
            <div class="comparison-item locks">
                <h4>Locks Expl√≠citos</h4>
                <ul>
                    <li><strong>Vantagens:</strong>
                        <ul>
                            <li>Cria√ß√£o din√¢mica em runtime</li>
                            <li>Totalmente escal√°vel</li>
                            <li>Controle fino de sincroniza√ß√£o</li>
                            <li>Flexibilidade m√°xima</li>
                        </ul>
                    </li>
                    <li><strong>Desvantagens:</strong>
                        <ul>
                            <li>Gerenciamento manual necess√°rio</li>
                            <li>Sintaxe mais verbosa</li>
                            <li>Possibilidade de deadlocks</li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>

        <h2>ÔøΩ Passo a Passo: Execu√ß√£o das Duas Listas com Regi√µes Cr√≠ticas Nomeadas</h2>
        
        <div class="highlight">
            <h4>üéØ Entrada do Usu√°rio:</h4>
            <ul>
                <li><strong>Inser√ß√µes:</strong> 5000</li>
                <li><strong>Threads:</strong> 4</li>
            </ul>
        </div>

        <h3>Fluxo de Execu√ß√£o - Primeira Parte:</h3>
        
        <ol>
            <li>
                <strong>üèóÔ∏è Inicializa√ß√£o:</strong>
                <ul>
                    <li>Criar duas listas globais: <code>global_list1</code> e <code>global_list2</code></li>
                    <li>Inicializar cada lista com: head = NULL, count = 0 ‚Üí <code>init_simple_list()</code></li>
                    <li>Marcar tempo inicial: <code>start_time = omp_get_wtime()</code></li>
                </ul>
            </li>
            
            <li>
                <strong>üöÄ Regi√£o Paralela:</strong>
                <ul>
                    <li>Criar 4 threads com <code>#pragma omp parallel num_threads(4)</code></li>
                    <li>Thread principal (single) cria 5000 tasks</li>
                    <li>Outras 3 threads aguardam tasks na fila de trabalho</li>
                </ul>
            </li>
            
            <li>
                <strong>‚ö° Execu√ß√£o das Tasks:</strong>
                <ul>
                    <li>Cada task gera seed √∫nico: <code>time() + omp_get_thread_num() + task_id</code></li>
                    <li>Escolhe aleatoriamente: lista 1 (choice=0) ou lista 2 (choice=1) ‚Üí <code>rand_r()</code></li>
                    <li>Gera valor aleat√≥rio entre 0-999 para inserir ‚Üí <code>rand_r()</code></li>
                </ul>
            </li>
            
            <li>
                <strong>üîí Inser√ß√£o com Regi√µes Cr√≠ticas:</strong>
                <ul>
                    <li><strong>Lista 1:</strong> <code>#pragma omp critical(lista1)</code> ‚Üí <code>insert_list1_critical()</code></li>
                    <li><strong>Lista 2:</strong> <code>#pragma omp critical(lista2)</code> ‚Üí <code>insert_list2_critical()</code></li>
                    <li><strong>Cria√ß√£o de n√≥s:</strong> Aloca mem√≥ria para novos n√≥s ‚Üí <code>create_node()</code></li>
                    <li><strong>Prote√ß√£o:</strong> Apenas uma thread por lista por vez</li>
                </ul>
            </li>
            
            <li>
                <strong>‚è±Ô∏è Finaliza√ß√£o:</strong>
                <ul>
                    <li>Aguardar todas as 5000 tasks terminarem (taskwait impl√≠cito)</li>
                    <li>Sincronizar todas as 4 threads</li>
                    <li>Medir tempo final e calcular dura√ß√£o ‚Üí <code>omp_get_wtime()</code></li>
                </ul>
            </li>
            
            <li>
                <strong>üìä Resultados:</strong>
                <ul>
                    <li>Imprimir conte√∫do das listas ‚Üí <code>print_simple_list()</code></li>
                    <li><strong>Lista 1:</strong> 2542 elementos (50.84%)</li>
                    <li><strong>Lista 2:</strong> 2458 elementos (49.16%)</li>
                    <li><strong>Tempo:</strong> 2.9895 segundos</li>
                    <li><strong>Throughput:</strong> 1672 opera√ß√µes/segundo</li>
                </ul>
            </li>
            
            <li>
                <strong>üßπ Limpeza:</strong>
                <ul>
                    <li>Liberar mem√≥ria de todos os n√≥s ‚Üí <code>destroy_simple_list()</code></li>
                </ul>
            </li>
        </ol>

        <h2>üìã Passo a Passo: Execu√ß√£o de N Listas com Locks Expl√≠citos</h2>
        
        <div class="highlight">
            <h4>üéØ Entrada do Usu√°rio:</h4>
            <ul>
                <li><strong>Listas:</strong> 20</li>
                <li><strong>Inser√ß√µes:</strong> 5000 (mesmo valor anterior)</li>
                <li><strong>Threads:</strong> 4 (mesmo valor anterior)</li>
            </ul>
        </div>

        <h3>Fluxo de Execu√ß√£o - Segunda Parte:</h3>
        
        <ol>
            <li>
                <strong>üèóÔ∏è Aloca√ß√£o Din√¢mica:</strong>
                <ul>
                    <li>Alocar array de 20 estruturas <code>LockedList</code> ‚Üí <code>malloc()</code></li>
                    <li>Cada estrutura cont√©m: head, count, id, <strong>omp_lock_t lock</strong></li>
                    <li>Inicializar cada lista com locks ‚Üí <code>init_locked_list()</code> ‚Üí <code>omp_init_lock()</code></li>
                </ul>
            </li>
            
            <li>
                <strong>üöÄ Regi√£o Paralela:</strong>
                <ul>
                    <li>Mesmo padr√£o: 4 threads, 5000 tasks</li>
                    <li>Thread principal cria tasks, outras executam</li>
                    <li>Cada task recebe c√≥pia do array de listas</li>
                </ul>
            </li>
            
            <li>
                <strong>‚ö° Execu√ß√£o das Tasks:</strong>
                <ul>
                    <li>Seed √∫nico para cada task ‚Üí <code>time() + omp_get_thread_num() + task_id</code></li>
                    <li>Escolha aleat√≥ria entre as <strong>20 listas</strong> ‚Üí <code>rand_r()</code></li>
                    <li>Acesso din√¢mico: <code>lists[choice]</code></li>
                </ul>
            </li>
            
            <li>
                <strong>üîí Inser√ß√£o com Locks Expl√≠citos:</strong>
                <ul>
                    <li><strong>Cria√ß√£o de n√≥s:</strong> Aloca mem√≥ria ‚Üí <code>create_node()</code></li>
                    <li><strong>Aquisi√ß√£o:</strong> <code>omp_set_lock(&list->lock)</code></li>
                    <li><strong>Inser√ß√£o:</strong> Modificar head, incrementar count ‚Üí <code>insert_locked_list()</code></li>
                    <li><strong>Libera√ß√£o:</strong> <code>omp_unset_lock(&list->lock)</code></li>
                    <li><strong>Vantagem:</strong> Cada lista tem lock independente</li>
                </ul>
            </li>
            
            <li>
                <strong>‚è±Ô∏è Finaliza√ß√£o:</strong>
                <ul>
                    <li>Aguardar 5000 tasks (mesmo processo)</li>
                    <li>Sincroniza√ß√£o autom√°tica das threads</li>
                    <li>C√°lculo de tempo de execu√ß√£o ‚Üí <code>omp_get_wtime()</code></li>
                </ul>
            </li>
            
            <li>
                <strong>üìä Resultados:</strong>
                <ul>
                    <li>Imprimir conte√∫do de todas as listas ‚Üí <code>print_locked_list()</code></li>
                    <li><strong>20 Listas:</strong> 212-288 elementos cada (distribui√ß√£o equilibrada)</li>
                    <li><strong>Tempo:</strong> 1.7177 segundos (<strong>42.5% mais r√°pido!</strong>)</li>
                    <li><strong>Throughput:</strong> 2911 opera√ß√µes/segundo</li>
                    <li><strong>Escalabilidade:</strong> 10x mais listas com melhor performance</li>
                </ul>
            </li>
            
            <li>
                <strong>üßπ Limpeza:</strong>
                <ul>
                    <li>Destruir todos os 20 locks ‚Üí <code>destroy_locked_list()</code> ‚Üí <code>omp_destroy_lock()</code></li>
                    <li>Liberar mem√≥ria de todos os n√≥s das listas ‚Üí <code>free()</code></li>
                    <li>Liberar array principal ‚Üí <code>free(lists)</code></li>
                </ul>
            </li>
        </ol>
        <h2>üìà An√°lise de Resultados</h2>
        
        <h3>Exemplo de Sa√≠da do Programa - Teste de Alta Carga</h3>
        <div class="output-sample">
<span class="header">TAREFA 9: Regi√µes Cr√≠ticas Nomeadas vs Locks Expl√≠citos</span>
<span class="header">========================================================</span>

<span class="input">Digite o n√∫mero de inser√ß√µes: Digite o n√∫mero de threads:</span>

<span class="section">=== DUAS LISTAS COM REGI√ïES CR√çTICAS NOMEADAS ===</span>
Inser√ß√µes: 5000 | Threads: 4

<span class="result">Resultados ap√≥s 5000 inser√ß√µes:</span>
  Lista 1 (2542 elementos): 197 393 197 197 375 294 294 147 300 300 48 48 801...
  Lista 2 (2458 elementos): 827 112 56 614 506 310 437 455 455 437 466 391 686...
  <span class="time">Tempo total: 2.9895 segundos</span>
  Total de elementos: 5000

<span class="input">Digite o n√∫mero de listas para a vers√£o generalizada:</span>

<span class="section">=== 20 LISTAS COM LOCKS EXPL√çCITOS ===</span>
Inser√ß√µes: 5000 | Threads: 4

<span class="result">Resultados ap√≥s 5000 inser√ß√µes em 20 listas:</span>
  Lista 1 (228 elementos): 780 813 813 446 200 200 804 804 860 981 819...
  Lista 2 (242 elementos): 112 260 758 313 850 850 276 276 424 601 328...
  Lista 3 (268 elementos): 801 801 585 585 738 738 216 691 697 697 911...
  Lista 4 (277 elementos): 130 130 614 827 614 614 981 635 518 518 847...
  Lista 5 (288 elementos): 147 147 694 362 621 626 626 735 735 735 668...
  ... (15 listas adicionais) ...
  Lista 20 (212 elementos): 488 791 304 304 325 388 959 959 959 844 436...
  <span class="time">Tempo total: 1.7177 segundos</span>
  Total de elementos: 5000
        </div>

        <h3>Observa√ß√µes dos Resultados</h3>
        
        <div class="success">
            <strong>‚úÖ Distribui√ß√£o Aleat√≥ria em Alta Escala:</strong> Com 5000 inser√ß√µes, a distribui√ß√£o foi praticamente equilibrada: Lista 1 recebeu 2542 elementos (50.84%) e Lista 2 recebeu 2458 elementos (49.16%). Entre 20 listas, a distribui√ß√£o variou de 212 a 288 elementos por lista, demonstrando aleatoriedade efetiva.
        </div>
        
        <div class="success">
            <strong>‚úÖ Integridade dos Dados em Alta Carga:</strong> O total de elementos inseridos (5000) corresponde exatamente √† soma dos elementos em todas as listas em ambas as execu√ß√µes, comprovando que n√£o houve condi√ß√µes de corrida mesmo com alta concorr√™ncia.
        </div>
        
        <div class="success">
            <strong>‚úÖ Performance Superior com Locks Expl√≠citos:</strong> Para 5000 inser√ß√µes, os locks expl√≠citos (1.7177s) foram <strong>42.5% mais r√°pidos</strong> que regi√µes cr√≠ticas nomeadas (2.9895s), demonstrando a superioridade da abordagem para cen√°rios de alta carga.
        </div>
        
        <div class="success">
            <strong>‚úÖ Paralelismo Efetivo:</strong> O tempo de execu√ß√£o √© baixo, indicando que as inser√ß√µes est√£o acontecendo em paralelo sem bloqueios desnecess√°rios.
        </div>

        <h3>An√°lise de Performance</h3>
        
        <table>
            <tr>
                <th>Abordagem</th>
                <th>Inser√ß√µes</th>
                <th>Listas</th>
                <th>Tempo (s)</th>
                <th>Throughput (ops/s)</th>
                <th>Escalabilidade</th>
            </tr>
            <tr>
                <td><strong>Regi√µes Cr√≠ticas Nomeadas</strong></td>
                <td>5000</td>
                <td>2</td>
                <td>2.9895</td>
                <td>1672</td>
                <td>‚ùå Limitado a nomes fixos</td>
            </tr>
            <tr>
                <td><strong>Locks Expl√≠citos</strong></td>
                <td>5000</td>
                <td>20</td>
                <td>1.7177</td>
                <td>2911</td>
                <td>‚úÖ Ilimitado</td>
            </tr>
        </table>

        <h2>üéØ Conclus√µes</h2>
        
        <div class="warning">
            <h4>Por que Regi√µes Cr√≠ticas Nomeadas n√£o s√£o suficientes para N listas?</h4>
            <ol>
                <li><strong>Limita√ß√£o de Compila√ß√£o:</strong> Os nomes das regi√µes cr√≠ticas devem ser literais conhecidos em tempo de compila√ß√£o</li>
                <li><strong>Impossibilidade de Generaliza√ß√£o:</strong> N√£o podemos criar nomes dinamicamente como "lista1", "lista2", ..., "listaN"</li>
                <li><strong>C√≥digo Est√°tico:</strong> Para 100 listas, precisar√≠amos escrever 100 se√ß√µes cr√≠ticas diferentes no c√≥digo</li>
            </ol>
        </div>
        
        <div class="success">
            <h4>Vantagens dos Locks Expl√≠citos:</h4>
            <ol>
                <li><strong>Cria√ß√£o Din√¢mica:</strong> Locks podem ser criados em arrays ou estruturas em runtime</li>
                <li><strong>Escalabilidade Total:</strong> Funciona para qualquer n√∫mero N de listas</li>
                <li><strong>Flexibilidade:</strong> Permite implementa√ß√µes mais complexas de sincroniza√ß√£o</li>
                <li><strong>Efici√™ncia:</strong> Cada lista tem seu pr√≥prio lock independente</li>
            </ol>
        </div>
        
        

        
            
        <h2>ÔøΩüí° Conceitos Aprendidos</h2>
        
        <ul>
            <li><strong>OpenMP Tasks:</strong> Cria√ß√£o din√¢mica de unidades de trabalho paralelo</li>
            <li><strong>Sincroniza√ß√£o Granular:</strong> Diferentes abordagens para proteger estruturas de dados</li>
            <li><strong>Thread Safety:</strong> Uso de rand_r() para gera√ß√£o de n√∫meros aleat√≥rios thread-safe</li>
            <li><strong>Gest√£o de Mem√≥ria:</strong> Aloca√ß√£o e libera√ß√£o adequada de estruturas din√¢micas</li>
            <li><strong>An√°lise de Performance:</strong> Medi√ß√£o de tempo e avalia√ß√£o de paralelismo</li>
        </ul>
        
        <div class="highlight">
            <strong>Li√ß√£o Principal:</strong> A escolha entre diferentes mecanismos de sincroniza√ß√£o deve considerar n√£o apenas a funcionalidade, mas tamb√©m a escalabilidade e flexibilidade da solu√ß√£o. Regi√µes cr√≠ticas nomeadas s√£o excelentes para casos simples e conhecidos, enquanto locks expl√≠citos oferecem m√°xima flexibilidade para solu√ß√µes escal√°veis.
        </div>

        <div style="text-align: center; margin: 30px 0;">
            <img src="tarefa9.png" alt="Tarefa 9" style="max-width: 100%; height: auto; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
        </div>
    </div>
</body>
</html>
