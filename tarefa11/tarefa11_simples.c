/*
 * ============================================================================
 * SIMULA√á√ÉO NAVIER-STOKES COM OPENMP E INSTRUMENTA√á√ÉO PASCAL
 * ============================================================================
 * 
 * Este programa implementa uma simula√ß√£o simplificada da equa√ß√£o de Navier-Stokes
 * para an√°lise de escalabilidade com diferentes n√∫meros de cores e estrat√©gias
 * de paraleliza√ß√£o (schedule static vs collapse).
 * 
 * COMPILA√á√ÉO:
 * -----------
 * 
 * 1. SEM PaScal (compila√ß√£o b√°sica):
 *    gcc -O2 -fopenmp tarefa11_simples.c -o tarefa11_simples -lm
 * 
 * 2. COM PaScal (instrumenta√ß√£o manual):
 *    gcc -O2 -fopenmp -DUSE_PASCAL tarefa11_simples.c -o tarefa11_simples -lm -lmpascalops
 * 
 * EXECU√á√ÉO:
 * ---------
 * 
 * 1. Execu√ß√£o b√°sica:
 *    ./tarefa11_simples [grid_size] [iterations]
 *    Exemplo: ./tarefa11_simples 1024 3000
 * 
 * 2. An√°lise com PaScal Analyzer:
 *    pascalanalyzer ./tarefa11_simples --inst man --cors 2,4,8 --ipts "1024 3000","2048 6000" --verb INFO
 * 
 * REGI√ïES DE INSTRUMENTA√á√ÉO PASCAL:
 * ---------------------------------
 * 
 * Regi√£o 100: Programa completo
 * Regi√£o 1:   Simula√ß√£o serial completa
 * Regi√£o 11:  Loop principal serial
 * Regi√£o 12:  C√≥pia de dados serial
 * Regi√£o 2:   Simula√ß√£o paralela static completa  
 * Regi√£o 21:  Loop principal paralelo static
 * Regi√£o 22:  C√≥pia de dados paralela static
 * Regi√£o 3:   Simula√ß√£o paralela collapse completa
 * Regi√£o 31:  Loop principal paralelo collapse
 * Regi√£o 32:  C√≥pia de dados paralela collapse
 * 
 * PAR√ÇMETROS:
 * -----------
 * - N: Tamanho da grade (NxN pontos)
 * - ITER: N√∫mero de itera√ß√µes temporais
 * - DT: Passo temporal (0.00001 para estabilidade)
 * - NU: Viscosidade cinem√°tica (0.1)
 * 
 * ALGORITMO:
 * ----------
 * - Implementa apenas a parte de viscosidade da equa√ß√£o de Navier-Stokes
 * - Usa diferen√ßas finitas para aproximar o Laplaciano
 * - Condi√ß√µes de contorno: velocidade zero nas bordas
 * - Perturba√ß√£o inicial: distribui√ß√£o gaussiana no centro
 * 
 * AN√ÅLISE DE ESCALABILIDADE:
 * --------------------------
 * - Compara performance serial vs paralela
 * - Testa 2, 4 e 8 cores
 * - Analisa schedule static vs collapse
 * - Calcula speedup e efici√™ncia
 * 
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <omp.h>

// Incluir PaScal apenas se dispon√≠vel
#ifdef USE_PASCAL
#include "pascalops.h"
#define PASCAL_START(id) pascal_start(id) // Macro para iniciar medi√ß√£o de regi√£o
#define PASCAL_STOP(id) pascal_stop(id)   // Macro para parar medi√ß√£o de regi√£o
#else
// Macros vazias quando PaScal n√£o est√° dispon√≠vel (compila√ß√£o condicional)
#define PASCAL_START(id) do {} while(0)
#define PASCAL_STOP(id) do {} while(0)
#endif

// Par√¢metros da simula√ß√£o (vari√°veis via linha de comando)
int N = 1024;        // Grade NxN pontos (padr√£o robusto para an√°lise significativa)
int ITER = 3000;     // N√∫mero de itera√ß√µes (padr√£o robusto para an√°lise significativa)
double DT = 0.00001; // Passo temporal (pequeno para estabilidade num√©rica)
double NU = 0.1;     // Viscosidade cinem√°tica (constante do fluido)

// Arrays din√¢micos para campos de velocidade
double **u, **v;         // Campos de velocidade atuais (u=horizontal, v=vertical)
double **u_new, **v_new; // Campos para pr√≥ximo passo temporal (double buffering)

// Fun√ß√£o para alocar matriz 2D dinamicamente
double** allocate_matrix(int rows, int cols) {
    double **matrix = (double**)malloc(rows * sizeof(double*)); // Aloca array de ponteiros para linhas
    for (int i = 0; i < rows; i++) {
        matrix[i] = (double*)calloc(cols, sizeof(double)); // Aloca e inicializa cada linha com zeros
    }
    return matrix;
}

// Fun√ß√£o para liberar matriz 2D
void free_matrix(double **matrix, int rows) {
    for (int i = 0; i < rows; i++) {
        free(matrix[i]); // Libera cada linha individual
    }
    free(matrix); // Libera o array de ponteiros
}

// Fun√ß√£o para calcular Laplaciano 2D (aproxima√ß√£o de diferen√ßas finitas)
double laplacian(double **field, int i, int j) {
    // Aproxima√ß√£o do operador Laplaciano usando diferen√ßas finitas centrais
    return field[i+1][j] + field[i-1][j] + field[i][j+1] + field[i][j-1] - 4.0 * field[i][j];
}

// Fun√ß√£o para inicializar condi√ß√µes de contorno
void apply_boundary_conditions() {
    // Condi√ß√µes de contorno: velocidade zero nas bordas
    for (int i = 0; i < N; i++) {
        u[i][0] = u[i][N-1] = 0.0;
        v[i][0] = v[i][N-1] = 0.0;
        u[0][i] = u[N-1][i] = 0.0;
        v[0][i] = v[N-1][i] = 0.0;
    }
}

// Fun√ß√£o para criar perturba√ß√£o inicial
void create_perturbation() {
    int center_x = N/2, center_y = N/2; // Centro da grade
    int radius = N/8; // Raio da perturba√ß√£o (1/8 do tamanho da grade)
    
    for (int i = center_x - radius; i <= center_x + radius; i++) {
        for (int j = center_y - radius; j <= center_y + radius; j++) {
            if (i >= 0 && i < N && j >= 0 && j < N) { // Verificar limites da grade
                double dx = i - center_x;
                double dy = j - center_y;
                double r = sqrt(dx*dx + dy*dy); // Dist√¢ncia do centro
                if (r <= radius) {
                    // Criar distribui√ß√£o gaussiana para velocidade inicial
                    u[i][j] = 0.5 * exp(-(r*r)/(radius*radius/4));
                    v[i][j] = 0.3 * exp(-(r*r)/(radius*radius/4));
                }
            }
        }
    }
}

// Simula√ß√£o serial (refer√™ncia)
double simulate_serial() {
    printf("üîÑ Executando vers√£o SERIAL...\n");
    
    PASCAL_START(1); // Regi√£o 1: Simula√ß√£o serial completa
    double start = omp_get_wtime(); // Marca tempo inicial
    
    for (int iter = 0; iter < ITER; iter++) {
        PASCAL_START(11); // Regi√£o 11: Loop principal serial
        
        // Atualizar campos de velocidade (equa√ß√£o da viscosidade)
        for (int i = 1; i < N-1; i++) { // Evita bordas (i=0 e i=N-1)
            for (int j = 1; j < N-1; j++) { // Evita bordas (j=0 e j=N-1)
                // Equa√ß√£o de difus√£o: u_novo = u_atual + dt * nu * laplaciano(u)
                u_new[i][j] = u[i][j] + DT * NU * laplacian(u, i, j);
                v_new[i][j] = v[i][j] + DT * NU * laplacian(v, i, j);
            }
        }
        
        PASCAL_STOP(11); // Fim do loop principal serial
        
        PASCAL_START(12); // Regi√£o 12: C√≥pia serial
        // Copiar valores calculados de volta para arrays principais
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                u[i][j] = u_new[i][j];
                v[i][j] = v_new[i][j];
            }
        }
        PASCAL_STOP(12); // Fim da c√≥pia serial
        
        apply_boundary_conditions(); // Reaplicar condi√ß√µes de contorno
    }
    
    double end = omp_get_wtime(); // Marca tempo final
    PASCAL_STOP(1); // Fim da simula√ß√£o serial completa
    
    double tempo = end - start;
    
    printf("   ‚è±Ô∏è  Tempo serial: %.4f segundos\n", tempo);
    printf("   üîÑ %.1f itera√ß√µes/segundo\n", ITER / tempo);
    
    return tempo; // Retorna tempo de execu√ß√£o para an√°lise de escalabilidade
}

// Simula√ß√£o paralela com schedule est√°tico
double simulate_parallel_static(int num_threads) {
    printf("üöÄ Executando vers√£o PARALELA (schedule static, %d threads)...\n", num_threads);
    
    PASCAL_START(2); // Regi√£o 2: Simula√ß√£o paralela static completa
    
    omp_set_num_threads(num_threads); // Define n√∫mero de threads OpenMP
    double start = omp_get_wtime(); // Marca tempo inicial
    
    for (int iter = 0; iter < ITER; iter++) {
        PASCAL_START(21); // Regi√£o 21: Loop principal paralelo static
        
        // Paraleliza√ß√£o do loop principal com distribui√ß√£o est√°tica de trabalho
        #pragma omp parallel for schedule(static)
        for (int i = 1; i < N-1; i++) {
            for (int j = 1; j < N-1; j++) {
                u_new[i][j] = u[i][j] + DT * NU * laplacian(u, i, j);
                v_new[i][j] = v[i][j] + DT * NU * laplacian(v, i, j);
            }
        }
        
        PASCAL_STOP(21); // Fim do loop principal paralelo static
        
        PASCAL_START(22); // Regi√£o 22: C√≥pia paralela static
        // Paraleliza√ß√£o da c√≥pia com distribui√ß√£o din√¢mica padr√£o
        #pragma omp parallel for
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                u[i][j] = u_new[i][j];
                v[i][j] = v_new[i][j];
            }
        }
        PASCAL_STOP(22); // Fim da c√≥pia paralela static
        
        apply_boundary_conditions(); // Reaplicar condi√ß√µes de contorno
    }
    
    double end = omp_get_wtime(); // Marca tempo final
    PASCAL_STOP(2); // Fim da simula√ß√£o paralela static completa
    
    double tempo = end - start;
    
    printf("   ‚è±Ô∏è  Tempo paralelo: %.4f segundos\n", tempo);
    printf("   üîÑ %.1f itera√ß√µes/segundo\n", ITER / tempo);
    
    return tempo; // Retorna tempo de execu√ß√£o para an√°lise de escalabilidade
}

// Simula√ß√£o paralela com collapse
double simulate_parallel_collapse(int num_threads) {
    printf("üöÄ Executando vers√£o PARALELA (collapse, %d threads)...\n", num_threads);
    
    PASCAL_START(3); // Regi√£o 3: Simula√ß√£o paralela collapse completa
    
    omp_set_num_threads(num_threads); // Define n√∫mero de threads OpenMP
    double start = omp_get_wtime(); // Marca tempo inicial
    
    for (int iter = 0; iter < ITER; iter++) {
        PASCAL_START(31); // Regi√£o 31: Loop principal paralelo collapse
        
        // Paraleliza√ß√£o com collapse - combina 2 loops em um espa√ßo de itera√ß√£o √∫nico
        #pragma omp parallel for collapse(2)
        for (int i = 1; i < N-1; i++) {
            for (int j = 1; j < N-1; j++) {
                u_new[i][j] = u[i][j] + DT * NU * laplacian(u, i, j);
                v_new[i][j] = v[i][j] + DT * NU * laplacian(v, i, j);
            }
        }
        
        PASCAL_STOP(31); // Fim do loop principal paralelo collapse
        
        PASCAL_START(32); // Regi√£o 32: C√≥pia paralela collapse
        // Paraleliza√ß√£o da c√≥pia tamb√©m com collapse para melhor distribui√ß√£o
        #pragma omp parallel for collapse(2)
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                u[i][j] = u_new[i][j];
                v[i][j] = v_new[i][j];
            }
        }
        PASCAL_STOP(32); // Fim da c√≥pia paralela collapse
        
        apply_boundary_conditions(); // Reaplicar condi√ß√µes de contorno
    }
    
    double end = omp_get_wtime(); // Marca tempo final
    PASCAL_STOP(3); // Fim da simula√ß√£o paralela collapse completa
    
    double tempo = end - start;
    
    printf("   ‚è±Ô∏è  Tempo paralelo: %.4f segundos\n", tempo);
    printf("   üîÑ %.1f itera√ß√µes/segundos\n", ITER / tempo);
    
    return tempo; // Retorna tempo de execu√ß√£o para an√°lise de escalabilidade
}

int main(int argc, char *argv[]) {
    // Processar argumentos da linha de comando
    if (argc >= 2) N = atoi(argv[1]); // Primeiro argumento: tamanho da grade
    if (argc >= 3) ITER = atoi(argv[2]); // Segundo argumento: n√∫mero de itera√ß√µes
    
    printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë           üåä SIMULA√á√ÉO NAVIER-STOKES COM OPENMP üåä              ‚ïë\n");
    printf("‚ïë                    An√°lise de Escalabilidade                     ‚ïë\n");
    #ifdef USE_PASCAL
    printf("‚ïë                 üìä INSTRUMENTADO COM PASCAL üìä                   ‚ïë\n");
    #endif
    printf("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n");
    printf("‚ïë üìè Grid: %dx%d pontos                                          ‚ïë\n", N, N);
    printf("‚ïë üîÑ Itera√ß√µes: %d                                               ‚ïë\n", ITER);
    printf("‚ïë ‚ö° Threads dispon√≠veis: %d                                      ‚ïë\n", omp_get_max_threads());
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n");
    
    #ifdef USE_PASCAL
    printf("üìä REGI√ïES DE INSTRUMENTA√á√ÉO PASCAL:\n");
    printf("   Regi√£o 1:  Simula√ß√£o serial completa\n");
    printf("   Regi√£o 11: Loop principal serial\n");
    printf("   Regi√£o 12: C√≥pia de dados serial\n");
    printf("   Regi√£o 2:  Simula√ß√£o paralela static completa\n");
    printf("   Regi√£o 21: Loop principal paralelo static\n");
    printf("   Regi√£o 22: C√≥pia de dados paralela static\n");
    printf("   Regi√£o 3:  Simula√ß√£o paralela collapse completa\n");
    printf("   Regi√£o 31: Loop principal paralelo collapse\n");
    printf("   Regi√£o 32: C√≥pia de dados paralela collapse\n\n");
    #endif
    
    PASCAL_START(100); // Regi√£o 100: Programa completo
    
    // Alocar matrizes dinamicamente para os campos de velocidade
    u = allocate_matrix(N, N);     // Campo de velocidade u atual
    v = allocate_matrix(N, N);     // Campo de velocidade v atual
    u_new = allocate_matrix(N, N); // Campo de velocidade u para pr√≥ximo passo
    v_new = allocate_matrix(N, N); // Campo de velocidade v para pr√≥ximo passo
    
    // Aplicar condi√ß√µes iniciais
    create_perturbation();    // Criar perturba√ß√£o gaussiana no centro
    apply_boundary_conditions(); // Aplicar condi√ß√µes de contorno (velocidade zero nas bordas)
    
    // Array para armazenar tempos de execu√ß√£o
    double tempo_serial;
    double tempos_paralelos[3]; // Para 2, 4 e 8 threads
    int cores[] = {2, 4, 8};    // Configura√ß√µes de threads a testar
    
    // TESTE 1: Vers√£o Serial
    printf("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
    tempo_serial = simulate_serial();
    
    // TESTE 2: Vers√µes Paralelas (schedule static)
    printf("\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
    printf("                    TESTE SCHEDULE STATIC\n");
    printf("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
    
    for (int i = 0; i < 3; i++) {
        // Resetar condi√ß√µes para cada teste para garantir compara√ß√£o justa
        create_perturbation();
        apply_boundary_conditions();
        
        tempos_paralelos[i] = simulate_parallel_static(cores[i]);
        printf("\n");
    }
    
    // TESTE 3: Vers√µes Paralelas (collapse)
    printf("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
    printf("                     TESTE COLLAPSE\n");
    printf("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");
    
    double tempos_collapse[3]; // Armazenar tempos das execu√ß√µes collapse
    for (int i = 0; i < 3; i++) {
        // Resetar condi√ß√µes para cada teste para garantir compara√ß√£o justa
        create_perturbation();
        apply_boundary_conditions();
        
        tempos_collapse[i] = simulate_parallel_collapse(cores[i]);
        printf("\n");
    }
    
    // AN√ÅLISE DE RESULTADOS
    printf("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n");
    printf("‚ïë                    üìä AN√ÅLISE DE ESCALABILIDADE                  ‚ïë\n");
    printf("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n");
    printf("‚ïë Tempo Serial: %.4f segundos                                    ‚ïë\n", tempo_serial);
    printf("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n");
    printf("‚ïë                       SCHEDULE STATIC                            ‚ïë\n");
    for (int i = 0; i < 3; i++) {
        double speedup = tempo_serial / tempos_paralelos[i]; // Calcular acelera√ß√£o
        double eficiencia = speedup / cores[i] * 100;       // Calcular efici√™ncia percentual
        printf("‚ïë %d cores: %.4fs (speedup: %.2fx, efici√™ncia: %.1f%%)           ‚ïë\n", 
               cores[i], tempos_paralelos[i], speedup, eficiencia);
    }
    printf("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£\n");
    printf("‚ïë                         COLLAPSE                                 ‚ïë\n");
    for (int i = 0; i < 3; i++) {
        double speedup = tempo_serial / tempos_collapse[i]; // Calcular acelera√ß√£o
        double eficiencia = speedup / cores[i] * 100;      // Calcular efici√™ncia percentual
        printf("‚ïë %d cores: %.4fs (speedup: %.2fx, efici√™ncia: %.1f%%)           ‚ïë\n", 
               cores[i], tempos_collapse[i], speedup, eficiencia);
    }
    printf("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n");
    
    PASCAL_STOP(100); // Fim do programa completo
    
    // Liberar mem√≥ria alocada dinamicamente
    free_matrix(u, N);
    free_matrix(v, N);
    free_matrix(u_new, N);
    free_matrix(v_new, N);
    
    #ifdef USE_PASCAL
    printf("\nüìÅ Dados PaScal coletados para an√°lise de escalabilidade.\n");
    printf("üí° Use pascalanalyzer para an√°lise autom√°tica:\n");
    printf("   pascalanalyzer ./tarefa11_simples --inst man --cors 2,4,8 --ipts \"%d %d\" --verb INFO\n", N, ITER);
    #endif
    
    printf("\n‚ú® An√°lise de escalabilidade conclu√≠da! ‚ú®\n");
    
    return 0;
}
//export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$(pwd)/pascal-releases-master/lib && ./pascal-releases-master/bin/pascalanalyzer ./tarefa11_simples_pascal --inst man --cors 2,4,6,8 --ipts "512 1500","1024 3000","2048 6000" --outp pascalanalysis.json --verb INFO
//export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$(pwd)/pascal-releases-master/lib && ./pascal-releases-master/bin/pascalanalyzer ./tarefa11_simples_pascal --inst man --cors 2,4,8 --ipts "1024 3000","2048 6000","4096 12000" --rpts 2 --outp pascal_analysis.json --verb INFO
